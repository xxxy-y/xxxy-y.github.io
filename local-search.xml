<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>单例模式</title>
    <link href="/2023/10/24/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <url>/2023/10/24/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="单例模式是什么？"><a href="#单例模式是什么？" class="headerlink" title="单例模式是什么？"></a>单例模式是什么？</h2><p>单例模式（<code>Singleton Pattern</code>）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式。保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p><p>单例模式一般体现在类声明中，单例的类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。</p><h2 id="单例模式的优点"><a href="#单例模式的优点" class="headerlink" title="单例模式的优点"></a>单例模式的优点</h2><ol><li>在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如网站首页页面缓存）。</li><li>避免对资源的多重占用（比如写文件操作）。</li></ol><h2 id="单例模式的实现方式"><a href="#单例模式的实现方式" class="headerlink" title="单例模式的实现方式"></a>单例模式的实现方式</h2><p>我们知道，一个类的对象的产生是由类构造函数来完成的。如果一个类对外提供了<code>public</code>的构造方法，那么外界就可以任意创建该类的对象。所以，如果想限制对象的产生，一个办法就是将构造函数变为私有的(至少是受保护的)，使外面的类不能通过引用来产生对象。同时为了保证类的可用性，就必须提供一个自己的对象以及访问这个对象的静态方法。</p><ol><li><h3 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h3></li></ol>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">// 饿汉式的两种写法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-comment">//在类内部实例化一个实例</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>    <span class="hljs-comment">//私有的构造函数,外部无法访问</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br>    <span class="hljs-comment">//对外提供获取实例的静态方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton2</span> &#123;<br>    <span class="hljs-comment">//在类内部定义</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton2 instance;<br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-comment">//实例化该实例</span><br>        instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton2</span>();<br>    &#125;<br>    <span class="hljs-comment">//私有的构造函数,外部无法访问</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton2</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br>    <span class="hljs-comment">//对外提供获取实例的静态方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton2 <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>  这种实现方式我们称之为饿汉式。所谓饿汉。这是个比较形象的比喻。对于一个饿汉来说，他希望他想要用到这个实例的时候就能够立即拿到，而不需要任何等待时间。所以，通过<code>static</code>的静态初始化方式，在该类第一次被加载的时候，就有一个<code>SimpleSingleton</code>的实例被创建出来了。这样就保证在第一次想要使用该对象时，他已经被初始化好了。同时，由于该实例在类被加载的时候就创建出来了，所以也避免了线程安全问题。</p><blockquote><p>饿汉式单例，在类被加载的时候对象就会实例化。这也许会造成不必要的消耗，因为有可能这个实例根本就不会被用到。而且，如果这个类被多次加载的话也会造成多次实例化。其实解决这个问题的方式有很多，下面提供两种解决方式，第一种是使用静态内部类的形式。第二种是使用懒汉式。</p></blockquote><blockquote><p>—为什么说饿汉式创建的实例在类被加载的时候就创建出来了，所以也避免了线程安全问题呢？</p><p>饿汉式创建的实例在类被加载的时候就被创建出来，那么调用单例的时候就会自动调用该创建的实例，所以不会导致线程安全问题。</p></blockquote><ol start="2"><li><h3 id="静态内部类式"><a href="#静态内部类式" class="headerlink" title="静态内部类式"></a>静态内部类式</h3> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//code 4</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StaticInnerClassSingleton</span> &#123;<br>    <span class="hljs-comment">//在静态内部类中初始化实例对象</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SingletonHolder</span> &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">StaticInnerClassSingleton</span> <span class="hljs-variable">INSTANCE</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StaticInnerClassSingleton</span>();<br>    &#125;<br>    <span class="hljs-comment">//私有的构造方法</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">StaticInnerClassSingleton</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br>    <span class="hljs-comment">//对外提供获取实例的静态方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> StaticInnerClassSingleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> SingletonHolder.INSTANCE;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>静态内部类的初始化是在被使用时才会被触发，而不是在类加载的过程中立即初始化。</p></blockquote><p> 这种方式同样利用了 classloder 的机制来保证初始化<code>instance</code>时只有一个线程，它跟饿汉式不同的是（很细微的差别）：饿汉式是只要<code>Singleton</code>类被装载了，那么<code>instance</code>就会被实例化（没有达到lazy loading效果），而这种方式是<code>Singleton</code>类被装载了，<code>instance</code>不一定被初始化。因为<code>SingletonHolder</code>类没有被主动使用，只有显示通过调用<code>getInstance</code>方法时，才会显示装载<code>SingletonHolder</code>类，从而实例化<code>instance</code>。想象一下，如果实例化<code>instance</code>很消耗资源，我想让他延迟加载，另外一方面，我不希望在<code>Singleton</code>类加载时就实例化，因为我不能确保<code>Singleton</code>类还可能在其他的地方被主动使用从而被加载，那么这个时候实例化<code>instance</code>显然是不合适的。这个时候，这种方式相比饿汉式更加合理。</p></li><li><h3 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h3> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">// 线程不安全的懒汉式</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">在多线程情况下，有可能两个线程同时进入if语句中，这样，在两个线程都从if中退出的时候就创建了两个不一样的对象。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-comment">//定义实例</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance;<br>    <span class="hljs-comment">//私有构造方法</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span>&#123;&#125;<br>    <span class="hljs-comment">//对外提供获取实例的静态方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//在对象被使用的时候才实例化</span><br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>            instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 线程安全的懒汉式</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">这种写法能够在多线程中很好的工作，而且看起来它也具备很好的延迟加载，但是，遗憾的是，他效率很低，因为99%情况下不需要同步。（因为上面的synchronized的加锁范围是整个方法，该方法的所有操作都是同步进行的，但是对于非第一次创建对象的情况，也就是没有进入if语句中的情况，根本不需要同步操作，可以直接返回instance。）</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SynchronizedSingleton</span> &#123;<br>    <span class="hljs-comment">//定义实例</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> SynchronizedSingleton instance;<br>    <span class="hljs-comment">//私有构造方法</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">SynchronizedSingleton</span><span class="hljs-params">()</span>&#123;&#125;<br>    <span class="hljs-comment">//对外提供获取实例的静态方法,对该方法加锁</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> SynchronizedSingleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//在对象被使用的时候才实例化</span><br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>            instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SynchronizedSingleton</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p> 懒汉，就是不会提前把实例创建出来，将类对自己的实例化延迟到第一次被引用的时候。<code>getInstance</code>方法的作用是希望该对象在第一次被使用的时候被<code>new</code>出来。</p></li><li><h3 id="双重校验锁"><a href="#双重校验锁" class="headerlink" title="双重校验锁"></a>双重校验锁</h3> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 解决懒汉式在线程安全的情况下，效率过低</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton singleton;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getSingleton</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (singleton == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">synchronized</span> (Singleton.class) &#123;<br>                <span class="hljs-keyword">if</span> (singleton == <span class="hljs-literal">null</span>) &#123;<br>                    singleton = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> singleton;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>实现了惰性初始化，解决了同步问题，还减小了锁的范围，提高了效率。</p></blockquote></li><li><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span>  <span class="hljs-title class_">Singleton</span> &#123;<br>    INSTANCE;<br>    Singleton() &#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h2><ol><li><p>如果单例由不同的类装载器装入，那便有可能存在多个单例类的实例。假定不是远端存取，例如一些servlet容器对每个servlet使用完全不同的类装载器，这样的话如果有两个servlet访问一个单例类，它们就都会有各自的实例。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 解决方法：指定类加载器的类型</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Class <span class="hljs-title function_">getClass</span><span class="hljs-params">(String classname)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException &#123;  <br>    <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">classLoader</span> <span class="hljs-operator">=</span> Thread.currentThread().getContextClassLoader();<br>    <span class="hljs-keyword">if</span>(classLoader == <span class="hljs-literal">null</span>) &#123;<br>        classLoader = Singleton.class.getClassLoader();     <br>        <span class="hljs-keyword">return</span> (classLoader.loadClass(classname));     <br>    &#125;     <br>&#125;  <br></code></pre></td></tr></table></figure></li><li><p>如果Singleton实现了java.io.Serializable接口，那么这个类的实例就可能被序列化和复原。不管怎样，如果你序列化一个单例类的对象，接下来复原多个那个对象，那你就会有多个单例类的实例。<a href="http://www.hollischuang.com/archives/1144">单例与序列化的那些事儿</a></p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">java</span>.io.Serializable &#123;     <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">INSTANCE</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();     <br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;     <br><br>    &#125;     <br>    <span class="hljs-keyword">private</span> Object <span class="hljs-title function_">readResolve</span><span class="hljs-params">()</span> &#123;     <br>        <span class="hljs-keyword">return</span> INSTANCE;     <br>    &#125;    <br>&#125;   <br></code></pre></td></tr></table></figure><blockquote><p>序列化是如何破坏单例模式的？如何避免序列化对单例的破坏？</p><p>见<a href="http://www.hollischuang.com/archives/1144">单例与序列化的那些事儿</a></p><p>序列化会通过反射调用无参数的构造方法创建一个新的对象。所以反射也可以破坏单例模式</p></blockquote></li></ol><p>在写代码时主要用到饿汉式、静态内部类、双重校验锁和枚举这几种实现单例模式的方式。</p><p>我比较喜欢饿汉式和静态内部类，简单易懂，而且在JVM层实现了线程安全（如果不是多个类加载器环境），一般的情况下，我会使用饿汉式，只有在要明确实现lazy loading效果时才会使用静态内部类，另外，如果涉及到反序列化创建对象时我会试着使用枚举的方式来实现单例，不过，我一直会保证我的程序是线程安全的，而且我永远不会使用懒汉式，如果有其他特殊的需求，我可能会使用双重校验锁，毕竟，JDK1.5已经没有双重检查锁定的问题了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java类的加载</title>
    <link href="/2023/10/24/Java%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD/"/>
    <url>/2023/10/24/Java%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.hollischuang.com/archives/199">源码解析</a></p><p><a href="https://www.hollischuang.com/archives/201">Java类的链接和初始化</a></p><h5 id="java中的类大致分为三种："><a href="#java中的类大致分为三种：" class="headerlink" title="java中的类大致分为三种："></a><strong>java中的类大致分为三种：</strong></h5><blockquote><p>1.系统类 。</p><p>2.扩展类 。</p><p>3.由程序员自定义的类。</p></blockquote><h5 id="类装载方式，有两种"><a href="#类装载方式，有两种" class="headerlink" title="类装载方式，有两种:"></a><strong>类装载方式，有两种:</strong></h5><blockquote><p>1.隐式装载， 程序在运行过程中当碰到通过new 等方式生成对象时，隐式调用类装载器加载对应的类到JVM中。 </p><p>2.显式装载， 通过class.forname()等方法，显式加载需要的类。</p></blockquote><h5 id="类加载的动态性体现"><a href="#类加载的动态性体现" class="headerlink" title="类加载的动态性体现:"></a><strong>类加载的动态性体现:</strong></h5><blockquote><p>一个应用程序总是由n多个类组成，Java程序启动时，并不是一次把所有的类全部加载后再运行，它总是先把保证程序运行的基础类一次性加载到jvm中，其它类等到jvm用到的时候再加载，这样的好处是节省了内存的开销，因为java最早就是为嵌入式系统而设计的，内存宝贵，这是一种可以理解的机制，而用到时再加载这也是java动态性的一种体现。</p></blockquote><h5 id="java类装载器"><a href="#java类装载器" class="headerlink" title="java类装载器"></a><strong>java类装载器</strong></h5><p>Java中的类装载器实质上也是类，功能是把类载入jvm中，值得注意的是jvm的类装载器并不是一个，而是三个，层次结构如下：</p><p><a href="http://www.hollischuang.com/wp-content/uploads/2015/04/image03.png"><img src="http://www.hollischuang.com/wp-content/uploads/2015/04/image03.png" alt="image03"></a></p><p>为什么要有三个类加载器，一方面是分工，各自负责各自的区块，另一方面为了实现委托模型。</p><h5 id="类加载器之间是如何协调工作的"><a href="#类加载器之间是如何协调工作的" class="headerlink" title="类加载器之间是如何协调工作的"></a><strong>类加载器之间是如何协调工作的</strong></h5><p>前面说了，java中有三个类加载器，问题就来了，碰到一个类需要加载时，它们之间是如何协调工作的，即java是如何区分一个类该由哪个类加载器来完成呢。 在这里java采用了<strong>委托模型机制</strong>，这个机制简单来讲，就是“<strong>类装载器有载入类的需求时，会先请示其Parent使用其搜索路径帮忙载入，如果Parent找不到,那么才由自己依照自己的搜索路径搜索类</strong>”</p><p><a href="http://www.hollischuang.com/wp-content/uploads/2015/04/image02.png"><img src="http://www.hollischuang.com/wp-content/uploads/2015/04/image02.png" alt="image02"></a></p><p>下面举一个例子来说明，为了更好的理解，先弄清楚几行代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">Public <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br>    Public <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] arg)</span>&#123;<br>        <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">c</span>  <span class="hljs-operator">=</span> Test.class.getClassLoader();  <span class="hljs-comment">//获取Test类的类加载器</span><br>        System.out.println(c); <br>        <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> c.getParent();  <span class="hljs-comment">//获取c这个类加载器的父类加载器</span><br>        System.out.println(c1);<br>        <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">c2</span> <span class="hljs-operator">=</span> c1.getParent();<span class="hljs-comment">//获取c1这个类加载器的父类加载器</span><br>        System.out.println(c2);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">AppClassLoader<br><br>ExtClassLoader<br><br>Null<br></code></pre></td></tr></table></figure><p>可以看出Test是由<strong>AppClassLoader</strong>加载器加载的，<strong>AppClassLoader</strong>的<code>Parent</code> 加载器是 <strong>ExtClassLoader</strong>,但是<code>ExtClassLoader</code>的<code>Parent</code>为 <code>null</code> 是怎么回事呵，那是因为 <strong>Bootstrap Loader</strong>是用C++语言写的，依java的观点来看，逻辑上并不存在<strong>Bootstrap Loader</strong>的类实体，所以在<code>java</code>程序代码里试图打印出其内容时，我们就会看到输出为<code>null</code>。</p><h5 id="类装载器ClassLoader（一个抽象类）描述一下JVM加载class文件的原理机制"><a href="#类装载器ClassLoader（一个抽象类）描述一下JVM加载class文件的原理机制" class="headerlink" title="类装载器ClassLoader（一个抽象类）描述一下JVM加载class文件的原理机制"></a>类装载器ClassLoader（一个抽象类）描述一下JVM加载class文件的原理机制</h5><p>类装载器就是寻找类或接口字节码文件进行解析并构造JVM内部对象表示的组件，在java中类装载器把一个类装入JVM，经过以下步骤：</p><blockquote><p>1、装载：查找和导入Class文件。</p><p>2、链接：其中解析步骤是可以选择的 </p><p>​（a）检查：检查载入的class文件数据的正确性 </p><p>​（b）准备：给类的静态变量分配存储空间 </p><p>​（c）解析：将符号引用转成直接引用 </p><p>3、初始化：对静态变量，静态代码块执行初始化工作</p></blockquote><p>类装载工作由<code>ClassLoder</code>和其子类负责。JVM在运行时会产生三个ClassLoader：<strong>根装载器</strong>，<code>ExtClassLoader</code>(<strong>扩展类装载器</strong>)和<code>AppClassLoader</code>，其中根装载器为Bootstrap Loader，它不是ClassLoader的子类，由C++编写，因此在java中看不到他，负责装载JRE的核心类库，如JRE目录下的rt.jar,charsets.jar等。<code>ExtClassLoader</code>是<code>ClassLoder</code>的子类，负责装载JRE扩展目录ext下的jar类包；**<code>AppClassLoader</code>负责装载classpath路径下的类包，这三个类装载器存在父子层级关系*<em>*<em>，即根装载器（Bootstrap Loader）是ExtClassLoader的父装载器，ExtClassLoader是AppClassLoader的父装载器。默认情况下使用AppClassLoader装载应用程序的类。</em></em></p><p>Java装载类使用“<strong>全盘负责委托机制</strong>”。“<strong>全盘负责</strong>”是指当一个<code>ClassLoder</code>装载一个类时，除非显示的使用另外一个<code>ClassLoder</code>，那么该类所依赖及引用的类也由这个<code>ClassLoder</code>载入；“<strong>委托机制</strong>”是指先委托父类装载器寻找目标类，只有在找不到的情况下才从自己的类路径中查找并装载目标类。这一点是从安全方面考虑的，试想如果一个人写了一个恶意的基础类（如<code>java.lang.String</code>）并加载到<code>JVM</code>将会引起严重的后果，但有了全盘负责制，<code>java.lang.String</code>永远是由根装载器来装载，避免以上情况发生 除了JVM默认的三个<code>ClassLoder</code>以外，第三方可以编写自己的类装载器，以实现一些特殊的需求。类文件被装载解析后，在<code>JVM</code>中都有一个对应的<code>java.lang.Class</code>对象，提供了类结构信息的描述。数组，枚举及基本数据类型，甚至<code>void</code>都拥有对应的<code>Class</code>对象。<code>Class</code>类没有<code>public</code>的构造方法，<code>Class</code>对象是在装载类时由<code>JVM</code>通过调用类装载器中的<code>defineClass()</code>方法自动构造的。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>println和print方法打印对象或实体时会自动调用toString方法</title>
    <link href="/2023/10/24/println%E5%92%8Cprint%E6%96%B9%E6%B3%95%E6%89%93%E5%8D%B0%E5%AF%B9%E8%B1%A1%E6%88%96%E5%AE%9E%E4%BD%93%E6%97%B6%E4%BC%9A%E8%87%AA%E5%8A%A8%E8%B0%83%E7%94%A8toString%E6%96%B9%E6%B3%95/"/>
    <url>/2023/10/24/println%E5%92%8Cprint%E6%96%B9%E6%B3%95%E6%89%93%E5%8D%B0%E5%AF%B9%E8%B1%A1%E6%88%96%E5%AE%9E%E4%BD%93%E6%97%B6%E4%BC%9A%E8%87%AA%E5%8A%A8%E8%B0%83%E7%94%A8toString%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>当我们打印对象或实体类时为什么会自动调用toString()方法?</p><p>我们可以先看看源码:</p><p>println(Object obj)源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">println</span><span class="hljs-params">(Object x)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> String.valueOf(x);<br>    <span class="hljs-keyword">if</span> (getClass() == PrintStream.class) &#123;<br>        <span class="hljs-comment">// need to apply String.valueOf again since first invocation</span><br>        <span class="hljs-comment">// might return null</span><br>        writeln(String.valueOf(s));<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>            print(s);<br>            newLine();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>print(Object obj)源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">(String s)</span> &#123;<br>    write(String.valueOf(s));<br>&#125;<br></code></pre></td></tr></table></figure><p>valueOf(Object obj)源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">valueOf</span><span class="hljs-params">(Object obj)</span> &#123;<br>    <span class="hljs-keyword">return</span> (obj == <span class="hljs-literal">null</span>) ? <span class="hljs-string">&quot;null&quot;</span> : obj.toString();<br>&#125;<br></code></pre></td></tr></table></figure><p>Object类的toString()定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> getClass().getName() + <span class="hljs-string">&quot;@&quot;</span> + Integer.toHexString(hashCode());<br>&#125;<br></code></pre></td></tr></table></figure><p>在源码层次，流程可以看作：</p><p>println(Object x)-&gt;print(String s)-&gt;valueOf(Object obj)-&gt;toString()</p><p>println(Object x)-&gt;valueOf(Object obj)-&gt;toString()</p><p>我们可以发现，当我们调用println()打印对象时，会在源码层面调用print()方法，而print方法又会调用String.valueOf()方法，而String.valueOf()方法最终会调用Object的toString()方法，该方法最终会返回getClass().getName() + “@” + Integer.toHexString(hashCode());也就是该符号字符的类的名称的字符串+“ @ ”和对象的哈希码的无符号的十六进制表示。</p><p>所以打印其实是把对象toString()方法返回的值打印出来。</p><p>因为所有的类都继承自object，object类具有一个toString()方法，创建的每个类都会继承该方法，返回对象的一个getClass().getName() + “@” + Integer.toHexString(hashCode())表示。</p><p>String自身重写了toString()方法，所以打印String对象，不需要重写toString方法，它可以直接打印出你需要的信息。</p><p>实体类的话，打印也会调用toString方法，但是需要自己重写toString方法。</p><p>toString的好处是在碰到“println”之类的输出方法时会自动调用，不用显式打出来。</p><p>一般的实体类都要重写toString() 、equals()、hashCode()等方法方法,如User ,Student等实体类，重写后当要打印实体时，则会自动调用你在实体类中重写的toString方法或者如果你没有重写该方法，那么会调用Object中的toString()方法。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>打印对象</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Maven中pom和import标签的作用</title>
    <link href="/2023/10/24/Maven%E4%B8%ADpom%E5%92%8Cimport%E6%A0%87%E7%AD%BE%E7%9A%84%E4%BD%9C%E7%94%A8/"/>
    <url>/2023/10/24/Maven%E4%B8%ADpom%E5%92%8Cimport%E6%A0%87%E7%AD%BE%E7%9A%84%E4%BD%9C%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>Maven pom类型中，发现有的依赖项添加了<code>&lt;scope&gt;import&lt;/scope&gt;</code>或者<code>&lt;type&gt;pom&lt;/pom&gt;</code>标签，有的没有添加，他们两个标签的作用是什么呢？</p><h3 id="import的作用"><a href="#import的作用" class="headerlink" title="&lt;scope&gt;import&lt;/scope&gt;的作用"></a><code>&lt;scope&gt;import&lt;/scope&gt;</code>的作用</h3><p>import只能用在<code>&lt;dependencyManagement&gt;&lt;/dependencyManagement&gt;</code>块中。</p><p>当我给一个项目指定一个父项目时，例如在 idea 中创建 springboot 项目，idea会自动创建 pom 文件，代码如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.1.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">relativePath</span>/&gt;</span> <span class="hljs-comment">&lt;!-- lookup parent from repository --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.example<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springCloudTest<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">packaging</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">packaging</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>springCloudTest1<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">description</span>&gt;</span>springCloudTest1<span class="hljs-tag">&lt;/<span class="hljs-name">description</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">modules</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">module</span>&gt;</span>user-service<span class="hljs-tag">&lt;/<span class="hljs-name">module</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">module</span>&gt;</span>book-service<span class="hljs-tag">&lt;/<span class="hljs-name">module</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">module</span>&gt;</span>borrow-service<span class="hljs-tag">&lt;/<span class="hljs-name">module</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">module</span>&gt;</span>commons<span class="hljs-tag">&lt;/<span class="hljs-name">module</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">module</span>&gt;</span>eureka-server<span class="hljs-tag">&lt;/<span class="hljs-name">module</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">modules</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">java.version</span>&gt;</span>17<span class="hljs-tag">&lt;/<span class="hljs-name">java.version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.0.28<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.example<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependencyManagement</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.baomidou<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.3.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2022.0.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencyManagement</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在这个pom文件中指定父项目为<code>spring-boot-starter-parent</code>，版本号为<code>3.1.4</code>。</p><p>父项目的定义可以帮助子项目继承和共享一些通用的配置和依赖管理。通过继承父项目，子项目可以继承父项目中的默认配置和依赖管理，从而减少重复配置和提高项目的一致性。</p><p>在上述代码片段中的<code>&lt;relativePath/&gt;</code>表示从本地的相对路径中查找父项目。当<code>&lt;relativePath/&gt;</code>为空时，Maven会在本地仓库或远程仓库中查找父项目的元数据信息。如果找不到，则会下载父项目的相关信息到本地仓库中。</p><p>通过指定父项目，可以方便地继承和管理通用的配置项、插件和依赖版本等，使项目的构建更加统一和便捷。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencyManagement</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-comment">&lt;!-- Import dependency management from Spring Boot --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.1.12.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencyManagement</span>&gt;</span><br></code></pre></td></tr></table></figure><p>带有<code>&lt;scope&gt;import&lt;/import&gt;</code>标签的这些dependency可以等价于直接在当前pom文件中定义的，而不是从父项目继承来的。</p><p>项目A和项目B的pom.xml文件中都定义了<code>&lt;dependencyManagement&gt;</code>，同时在B的<code>&lt;dependencyManagement&gt;</code>中定义<code>&lt;dependency&gt;</code>指向A，且<a href="https://so.csdn.net/so/search?q=scope&spm=1001.2101.3001.7020">scope</a>为<code>import</code>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- projectB.xml --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependencyManagement</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>project-A<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>project-A<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    ...<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencyManagement</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这就相当于将A中定义的所有<dependencies>全部复制粘贴到了项目B的pom.xml中。由于是“复制粘贴”，所以不是继承关系。</dependencies></p><p><code>&lt;scope&gt;import&lt;/scope&gt;</code>和<code>&lt;pom&gt;&lt;/pom&gt;</code>标签都是为了解决pom类型的父工程单继承的问题，通过导入，可以导入各种其他父工程的dependencyManagement。</p><h3 id="的作用"><a href="#的作用" class="headerlink" title="&lt;pom&gt;&lt;/pom&gt;的作用"></a><code>&lt;pom&gt;&lt;/pom&gt;</code>的作用</h3><p>当我们需要引入很多 jar 包的时候，会导致 pom.xml 过大，如使用 CXF 时，项目中可能要引入如下很多依赖包，此时，依赖包很多，导致 pom.xml 文件较大。我们可以想到的一种解决方案是定义一个父项目，但是父项目只有一个，也有可能导致父项目的 pom.xml 文件过大。这个时候我们引进来一个 type 为 pom，意味着我们可以将所有的 jar 包打包成一个 pom，然后我们依赖了 pom，即可以下载下来所有依赖的 jar 包。</p><p>当需要把一些依赖定义到一个pom工程中，但是由于maven单继承机制，子工程又想通过依赖引入该pom工程中的所有依赖，只需要添加<code>&lt;type&gt;pom&lt;/type&gt;</code>，如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>　　<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>　　　　  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.sonatype.mavenbook<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>persistence-deps<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>　　　　  <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这是为了解决子工程单继承的问题，通过<code>&lt;type&gt;pom&lt;/type&gt;</code>可以依赖于其他的pom父工程，从而将pom工程中的依赖都传递过来。</p><p>type 默认是jar，依赖jar工程时可以不写type标签，所以如果依赖于一个jar工程，而jar工程中包含大量的依赖，也会一起传递过来，这也就是maven依赖传递的原理。</p><p>那么问题来了，为了便于管理那么在父工程内dependencyManagement中添加了多个依赖，这对于子model来说就是多个父model(也可以理解为多个<code>&lt;parent&gt;&lt;/parent&gt;</code>标签)，而maven的继承和java的继承规范化是一致的，</p><p>那么如何处理让子model可以多继承父model，答案就是在每个依赖中添加<code>&lt;type&gt;pom&lt;/type&gt;</code>和<code>&lt;scope&gt;import&lt;/scope&gt;</code></p><p><code>&lt;type&gt; &lt;/type&gt;</code> 里的值默认值是jar表示引入的是jar包，这里使用的是pom表示导入的是父模块中的值import代表把父模块中的jar包导入进来，不过需要注意的是import,这种方式只能用在<code>&lt;dependencyManagement&gt;&lt;/dependencyManagement&gt;</code>块中。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Maven</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>jar文件的压缩和解压</title>
    <link href="/2023/10/23/jar%E6%96%87%E4%BB%B6%E7%9A%84%E5%8E%8B%E7%BC%A9%E5%92%8C%E8%A7%A3%E5%8E%8B/"/>
    <url>/2023/10/23/jar%E6%96%87%E4%BB%B6%E7%9A%84%E5%8E%8B%E7%BC%A9%E5%92%8C%E8%A7%A3%E5%8E%8B/</url>
    
    <content type="html"><![CDATA[<p>JAR（Java Archive）是Java的归档文件，它是一种与平台无关的文件格式，它允许将许多文件组合成一个压缩文件。</p><p>压缩&#x2F;解压jar包需要使用jdk&#x2F;bin&#x2F;jar.exe工具。</p><p>jar命令格式</p><p>jar {c t x u f } [v m e 0 M i ] [-C 目录] 文件名</p><p>{ctxu}中这四个参数必须选择其一</p><p>[v m e 0 M i] 和 [-C 目录] 这几个是可选参数</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-c</td><td>创建一个jar包</td></tr><tr><td>-t</td><td>显示jar中的内容列表</td></tr><tr><td>-x</td><td>解压jar包</td></tr><tr><td>-u</td><td>添加文件到jar包中</td></tr><tr><td>-f</td><td>指定jar包的文件名</td></tr><tr><td>-v</td><td>输出详细报告</td></tr><tr><td>-m</td><td>指定MANIFEST.MF文件</td></tr><tr><td>-0</td><td>生成jar包时不压缩内容</td></tr><tr><td>-M</td><td>不生成清单文件MANIFEST.MF</td></tr><tr><td>-i</td><td>为指定的jar文件创建索引文件</td></tr><tr><td>-C</td><td>可在相应的目录下执行命令</td></tr></tbody></table><p>cmd目录在哪个文件夹下，那么在cmd中运行 jar -xvf +(存放jar文件的路径和文件名)，就会将该jar文件解压到这个文件夹下。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>jar</tag>
      
      <tag>压缩</tag>
      
      <tag>解压</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java的编译原理</title>
    <link href="/2023/10/13/Java%E7%9A%84%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    <url>/2023/10/13/Java%E7%9A%84%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h4 id="Java编译原理"><a href="#Java编译原理" class="headerlink" title="Java编译原理"></a>Java编译原理</h4><p><strong>一个Java虚拟机（JVM）是从未被物理建成硬件假想计算机</strong>。而HotSpot虚拟机则是JVM的一种实现。</p><p>编程语言的编译过程一般分为前端编译和后端编译。</p><p>根据完成任务不同，可以将编译器的组成部分划分为前端（Front End）与后端（Back End）。</p><p>前端编译主要指与源语言有关但与目标机无关的部分，包括词法分析、语法分析、语义分析与中间代码生成。</p><p>后端编译主要指与目标机有关的部分，包括代码优化和目标代码生成等。</p><p><img src="/2023/10/13/Java%E7%9A%84%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/QQ20180414-203816.png"></p><h5 id="前端（Front-End）编译"><a href="#前端（Front-End）编译" class="headerlink" title="前端（Front End）编译"></a>前端（Front End）编译</h5><h6 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h6><p>词法分析阶段是编译过程的第一个阶段。这个阶段的任务是从左到右一个字符一个字符地读入源程序，将字符序列转换为标记（token）序列的过程。这里的标记是一个字符串，是构成源代码的最小单位。在这个过程中，词法分析器还会对标记进行分类。</p><p>词法分析器通常不会关心标记之间的关系（属于语法分析的范畴），举例来说：词法分析器能够将括号识别为标记，但并不保证括号是否匹配。</p><h6 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h6><p>语法分析的任务是在词法分析的基础上将单词序列组合成各类语法短语，如“程序”，“语句”，“表达式”等等.语法分析程序判断源程序在结构上是否正确.源程序的结构由上下文无关文法描述。</p><h6 id="语义分析"><a href="#语义分析" class="headerlink" title="语义分析"></a>语义分析</h6><p>语义分析是编译过程的一个逻辑阶段， 语义分析的任务是对结构上正确的源程序进行上下文有关性质的审查，进行类型审查。语义分析是审查源程序有无语义错误，为代码生成阶段收集类型信息。</p><p>语义分析的一个重要部分就是类型检查。比如很多语言要求数组下标必须为整数，如果使用浮点数作为下标，编译器就必须报错。再比如，很多语言允许某些类型转换，称为自动类型转换。</p><h6 id="中间代码生成"><a href="#中间代码生成" class="headerlink" title="中间代码生成"></a>中间代码生成</h6><p>在源程序的语法分析和语义分析完成之后，很多编译器生成一个明确的低级的或类机器语言的中间表示。该中间表示有两个重要的性质： 1.易于生成； 2.能够轻松地翻译为目标机器上的语言。</p><p>在Java中，<code>javac</code>执行的结果就是得到一个字节码，而这个字节码其实就是一种中间代码。</p><h5 id="后端（Back-End）编译"><a href="#后端（Back-End）编译" class="headerlink" title="后端（Back End）编译"></a>后端（Back End）编译</h5><p>JVM 通过解释字节码将其翻译成对应的机器指令，逐条读入，逐条解释翻译。</p><h6 id="JIT技术"><a href="#JIT技术" class="headerlink" title="JIT技术"></a>JIT技术</h6><p>但是在经过解释执行后，其执行速度必然会比可执行的二进制字节码程序慢很多。这就是传统的JVM的<strong>解释器（Interpreter，它是JVM中的一部分）</strong>的功能。为了解决这种效率问题，引入了 <strong>JIT</strong> 技术。</p><p>JAVA程序还是通过解释器进行解释执行，当JVM发现某个方法或代码块运行特别频繁的时候，就会认为这是“热点代码”（Hot Spot Code)。然后JIT会把部分“热点代码”<strong>翻译</strong>成本地机器相关的机器码，并进行<strong>优化</strong>，然后再把翻译后的机器码<strong>缓存</strong>起来，以备下次使用。</p><p>HotSpot虚拟机中内置了两个JIT编译器：Client Complier和Server Complier，分别用在客户端和服务端，目前主流的HotSpot虚拟机中默认是采用解释器与其中一个编译器直接配合的方式工作。</p><p>当 JVM 执行代码时，它并不立即开始编译代码。首先，如果这段代码本身在将来只会被执行一次，那么从本质上看，编译就是在浪费精力。因为将代码翻译成 java 字节码相对于编译这段代码并执行代码来说，要快很多。第二个原因是最优化，当 JVM 执行某一方法或遍历循环的次数越多，就会更加了解代码结构，那么 JVM 在编译代码的时候就做出相应的优化。</p><p>要想触发JIT，首先需要识别出热点代码。目前主要的热点代码识别方式是热点探测（Hot Spot Detection），有以下两种：</p><p>1、基于采样的方式探测（Sample Based Hot Spot Detection) ：周期性检测各个线程的栈顶，发现某个方法经常出险在栈顶，就认为是热点方法。好处就是简单，缺点就是无法精确确认一个方法的热度。容易受线程阻塞或别的原因干扰热点探测。</p><p>2、基于计数器的热点探测（Counter Based Hot Spot Detection)。采用这种方法的虚拟机会为每个方法，甚至是代码块建立计数器，统计方法的执行次数，某个方法超过阀值就认为是热点方法，触发JIT编译。</p><p>在HotSpot虚拟机中使用的是第二种——基于计数器的热点探测方法，因此它为每个方法准备了两个计数器：方法调用计数器和回边计数器。</p><p>方法计数器。记录一个方法被调用次数的计数器。</p><p>回边计数器。记录方法中的for或者while的运行次数的计数器。</p><h6 id="编译优化"><a href="#编译优化" class="headerlink" title="编译优化"></a>编译优化</h6><p>前面提到过，JIT除了具有缓存的功能外，还会对代码做各种优化。说到这里，不得不佩服HotSpot的开发者，他们在JIT中对于代码优化真的算是面面俱到了。</p><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>在Java语言中，我们可以把将<code>.java</code>文件通过 <code>jdk中的bin文件夹下的javac.exe</code> 编译成<code>.class</code>的编译过程称之为前端编译。把将<code>.class</code>文件通过 <code>JVM(jre中的bin文件夹可以看作为JVM)</code> 翻译成机器指令的编译过程称之为后端编译。</p><p><code>javac</code>的编译就是前端编译。除了这种以外，我们使用的很多IDE，如eclipse，idea等，都内置了前端编译器。主要功能就是把<code>.java</code>代码转换成<code>.class</code>代码（中间代码）。</p><p>JVM 通过解释字节码将其翻译成对应的机器指令，逐条读入，逐条解释翻译。</p><p><img src="/2023/10/13/Java%E7%9A%84%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/15539289530245.jpg"></p><p>因为JVM只要接收到.class文件便可以执行，它不管这个.class文件是怎么生成的，所以衍生出了很多新的编程语言，像Groovy、Scala、Kotlin等等，他们生成.class文件然后交给JVM来使用。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaShell工具（JShell）</title>
    <link href="/2023/10/12/JavaShell%E5%B7%A5%E5%85%B7%EF%BC%88JShell%EF%BC%89/"/>
    <url>/2023/10/12/JavaShell%E5%B7%A5%E5%85%B7%EF%BC%88JShell%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>REPL(Read Eval Print Loop)意为交互式的编程环境。</p><p>JShell 是 Java 1.9 新增的一个交互式的编程环境工具。它也被称为REPL，REPL(Read Eval Print Loop)意为交互式的编程环境。它允许你无需使用类或者方法包装来执行 Java 语句。它与 Python 的解释器类似，可以直接输入表达式并查看其执行结果。</p><p>一般在验证输入语句结果时才使用。</p><h4 id="JSHELL的基本使用"><a href="#JSHELL的基本使用" class="headerlink" title="JSHELL的基本使用"></a>JSHELL的基本使用</h4><p><strong>开启 JSHELL</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">$ jshell<br>|  欢迎使用 JShell -- 版本 <span class="hljs-number">21</span><br>|  要大致了解该版本, 请键入: /help intro<br></code></pre></td></tr></table></figure><p><strong>JSHELL 定义类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">jshell&gt; <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br>   ...&gt;     <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>   ...&gt;         System.out.println(<span class="hljs-string">&quot;hello world&quot;</span>);<br>   ...&gt;     &#125;<br>   ...&gt; &#125;<br>|  已创建 类 Test<br><br>jshell&gt; <span class="hljs-type">Test</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Test</span>();<br>o ==&gt; Test@3c0f93f1<br></code></pre></td></tr></table></figure><p><strong>JSHELL 定义接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java">jshell&gt; <span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Inter</span>&#123;<br>   ...&gt;     <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">interTest</span><span class="hljs-params">()</span>;<br>   ...&gt; &#125;<br>|  已创建 接口 Inter<br><br>jshell&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">InterImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Inter</span>&#123;<br>   ...&gt;     <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">interTest</span><span class="hljs-params">()</span>&#123;<br>   ...&gt;         System.out.println(<span class="hljs-string">&quot;Inter Test&quot;</span>);<br>   ...&gt;     &#125;<br>   ...&gt; &#125;<br>|  已创建 类 InterImpl<br><br>jshell&gt; <span class="hljs-type">Inter</span> <span class="hljs-variable">inter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterImpl</span>();<br>inter ==&gt; InterImpl@3327bd23<br><br>jshell&gt; inter.interTest();<br>Inter Test<br></code></pre></td></tr></table></figure><p><strong>JSHELL 声明变量、创建方法、调用方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">jshell&gt; <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>x ==&gt; <span class="hljs-number">1</span><br><br>jshell&gt; <span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br>y ==&gt; <span class="hljs-number">2</span><br><br>jshell&gt; <span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span>&#123;<br>   ...&gt; <span class="hljs-keyword">return</span> a + b;<br>   ...&gt; &#125;<br>|  已创建 方法 add(<span class="hljs-type">int</span>,<span class="hljs-type">int</span>)<br><br>jshell&gt; <span class="hljs-type">int</span> <span class="hljs-variable">z</span> <span class="hljs-operator">=</span> add(x,y);<br>z ==&gt; <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p><strong>JSHELL 读取外部文件并执行其中的片段</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">jshell&gt; </span><span class="language-bash">/open D:/develop/Test.txt</span><br></code></pre></td></tr></table></figure><h4 id="JSHELL-主要命令"><a href="#JSHELL-主要命令" class="headerlink" title="JSHELL 主要命令"></a>JSHELL 主要命令</h4><h6 id="list-all-start"><a href="#list-all-start" class="headerlink" title="&#x2F;list [&lt;名称或 id&gt;|-all|-start]"></a>&#x2F;list [&lt;名称或 id&gt;|-all|-start]</h6><p>功能：显示前面带有片段 ID 的片段源。</p><p>使用方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">/list<br>     列出您键入的或使用 /open 读取的当前活动的代码片段<br><br>/list -start<br>     列出自动评估的启动片段<br><br>/list -all<br>     列出所有片段, 包括失败的片段, 覆盖的片段, 删除的片段和启动片段<br><br>/list &lt;名称&gt;<br>     列出具有指定名称的片段 (特别是活动片段)<br><br>/list &lt;id&gt;<br>     列出具有指定片段 ID 的片段<br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java">jshell&gt; /list<br><br>   <span class="hljs-number">1</span> : <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br>           <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>               System.out.println(<span class="hljs-string">&quot;hello world&quot;</span>);<br>           &#125;<br>       &#125;<br>   <span class="hljs-number">2</span> : <span class="hljs-type">Test</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Test</span>();<br>   <span class="hljs-number">3</span> : <span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Inter</span>&#123;<br>           <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">interTest</span><span class="hljs-params">()</span>;<br>       &#125;<br>   <span class="hljs-number">4</span> : <span class="hljs-keyword">class</span> <span class="hljs-title class_">InterImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Inter</span>&#123;<br>           <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">interTest</span><span class="hljs-params">()</span>&#123;<br>               System.out.println(<span class="hljs-string">&quot;Inter Test&quot;</span>);<br>           &#125;<br>       &#125;<br>   <span class="hljs-number">5</span> : <span class="hljs-type">Inter</span> <span class="hljs-variable">inter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterImpl</span>();<br>   <span class="hljs-number">6</span> : inter.interTest();<br></code></pre></td></tr></table></figure><h6 id="edit"><a href="#edit" class="headerlink" title="&#x2F;edit &lt;名称或 id&gt;"></a>&#x2F;edit &lt;名称或 id&gt;</h6><p>功能：在外部编辑器中编辑源的片段。使用 &#x2F;set editor 可以设置要使用的编辑器。如果尚未设置编辑器, 则将启动一个简单的编辑器。</p><p>使用方法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">/edit &lt;名称&gt;<br>     编辑具有指定名称的片段 (特别是活动片段)<br><br>/edit &lt;id&gt;<br>     编辑具有指定片段 id 的片段<br><br>/edit<br>     编辑您键入或使用 /open 读取的当前活动的代码片段<br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">jshell&gt; /edit <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><img src="/2023/10/12/JavaShell%E5%B7%A5%E5%85%B7%EF%BC%88JShell%EF%BC%89/image-20231012190648917.png" alt="image-20231012190648917"></p><h6 id="drop"><a href="#drop" class="headerlink" title="&#x2F;drop &lt;名称或 id&gt;"></a>&#x2F;drop &lt;名称或 id&gt;</h6><p>功能：删除片段 – 使片段处于不活动状态。</p><p>使用方法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">/drop &lt;name&gt;<br>     删除具有指定名称的片段<br><br>/drop &lt;id&gt;<br>     删除具有指定片段 id 的片段<br></code></pre></td></tr></table></figure><p>示例：删除前文中的片段 6</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java">jshell&gt; /drop <span class="hljs-number">6</span><br><br>jshell&gt; /list<br><br>   <span class="hljs-number">1</span> : <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br>           <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>               System.out.println(<span class="hljs-string">&quot;hello world&quot;</span>);<br>           &#125;<br>       &#125;<br>   <span class="hljs-number">2</span> : <span class="hljs-type">Test</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Test</span>();<br>   <span class="hljs-number">3</span> : <span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Inter</span>&#123;<br>           <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">interTest</span><span class="hljs-params">()</span>;<br>       &#125;<br>   <span class="hljs-number">4</span> : <span class="hljs-keyword">class</span> <span class="hljs-title class_">InterImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Inter</span>&#123;<br>           <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">interTest</span><span class="hljs-params">()</span>&#123;<br>               System.out.println(<span class="hljs-string">&quot;Inter Test&quot;</span>);<br>           &#125;<br>       &#125;<br>   <span class="hljs-number">5</span> : <span class="hljs-type">Inter</span> <span class="hljs-variable">inter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterImpl</span>();<br></code></pre></td></tr></table></figure><h6 id="save-all-history-start"><a href="#save-all-history-start" class="headerlink" title="&#x2F;save [-all|-history|-start] &lt;文件&gt;"></a>&#x2F;save [-all|-history|-start] &lt;文件&gt;</h6><p>功能：将指定的片段和&#x2F;或命令保存到指定文件。</p><p>使用方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">/save &lt;文件&gt;<br>     将当前活动片段的源保存到文件<br><br>/save -all &lt;文件&gt;<br>     将所有片段的源保存到文件<br>     这包括覆盖的源, 失败的源以及启动代码<br><br>/save -history &lt;文件&gt;<br>     保存自启动 jshell 以来输入的所有命令和片段的顺序历史记录<br><br>/save -start &lt;文件&gt;<br>     将当前启动定义保存到文件<br></code></pre></td></tr></table></figure><p>示例：列出所有的片段，并保存到指定的文件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">jshell&gt; /save E:/test.txt<br></code></pre></td></tr></table></figure><p><img src="/2023/10/12/JavaShell%E5%B7%A5%E5%85%B7%EF%BC%88JShell%EF%BC%89/image-20231012190959683.png" alt="image-20231012190959683"></p><h6 id="open"><a href="#open" class="headerlink" title="&#x2F;open "></a>&#x2F;open <file></file></h6><p>功能：打开文件并读取其内容作为片段和命令。</p><p>使用方法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">/open &lt;file&gt;<br>     读取指定的文件作为 jshell 输入<br></code></pre></td></tr></table></figure><h6 id="vars-all-start"><a href="#vars-all-start" class="headerlink" title="&#x2F;vars [&lt;名称或 id&gt;|-all|-start]"></a>&#x2F;vars [&lt;名称或 id&gt;|-all|-start]</h6><p>功能： 列出 jshell 变量的类型, 名称和值。</p><p>使用方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">/vars<br>     列出当前活动的 jshell 变量的类型, 名称和值<br><br>/vars &lt;名称&gt;<br>     列出具有指定名称的 jshell 变量 (特别是活动变量)<br><br>/vars &lt;id&gt;<br>     列出具有指定片段 ID 的 jshell 变量<br><br>/vars -start<br>     列出自动添加的启动 jshell 变量<br><br>/vars -all<br>     列出所有 jshell 变量, 包括已失败变量, 已覆盖变量, 已删除变量和启动变量<br></code></pre></td></tr></table></figure><p>示例：列出所有变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">jshell&gt; /vars<br>    String[] str = String[<span class="hljs-number">1</span>] &#123; <span class="hljs-string">&quot;test&quot;</span> &#125;<br></code></pre></td></tr></table></figure><h6 id="methods-all-start"><a href="#methods-all-start" class="headerlink" title="&#x2F;methods [&lt;名称或 id&gt;|-all|-start]"></a>&#x2F;methods [&lt;名称或 id&gt;|-all|-start]</h6><p>功能：列出 jshell 方法的名称, 参数类型以及返回类型。</p><p>使用方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">/methods<br>     列出当前活动 jshell 方法名称, 参数类型和返回类型<br><br>/methods &lt;名称&gt;<br>     列出具有指定名称的 jshell 方法 (特别是活动方法)<br><br>/methods &lt;id&gt;<br>     列出具有指定片段 ID 的 jshell 方法<br><br>/methods -start<br>     列出自动添加的启动 jshell 方法<br><br>/methods -all<br>     列出所有片段, 包括已失败片段, 已覆盖片段, 已删除片段和启动片段<br></code></pre></td></tr></table></figure><p>示例：创建一个方法，列出所有方法，最后执行方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">jshell&gt; <span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span>&#123;<span class="hljs-keyword">return</span> a+b;&#125;<br>  已创建 方法 add(<span class="hljs-type">int</span>,<span class="hljs-type">int</span>)<br>jshell&gt; /methods<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span>,<span class="hljs-type">int</span>)</span><br>jshell&gt; add(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)<br>$<span class="hljs-number">8</span> ==&gt; <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h6 id="types-all-start"><a href="#types-all-start" class="headerlink" title="&#x2F;types [&lt;名称或 id&gt;|-all|-start]"></a>&#x2F;types [&lt;名称或 id&gt;|-all|-start]</h6><p>功能：列出 jshell 类, 接口和枚举。</p><p>使用方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">/types<br>     列出当前活动 jshell 类, 接口和枚举<br><br>/types &lt;名称&gt;<br>     列出具有指定名称的 jshell 类型 (特别是活动类型)<br><br>/types &lt;id&gt;<br>     列出具有指定片段 ID 的 jshell 类型<br><br>/types -start<br>     列出自动添加的启动 jshell 类型<br><br>/types -all<br>     列出所有 jshell 类型, 包括已失败, 已覆盖, 已删除和启动类型<br></code></pre></td></tr></table></figure><p>示例：创建一个接口，然后列出当前活动 jshell 类，接口和枚举。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">jshell&gt; <span class="hljs-keyword">interface</span> <span class="hljs-title class_">inter</span>&#123;<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>;&#125;<br>  已创建 接口 inter<br><br>jshell&gt; /types<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">OpenTest</span><br>    <span class="hljs-keyword">interface</span> <span class="hljs-title class_">inter</span><br></code></pre></td></tr></table></figure><h6 id="imports"><a href="#imports" class="headerlink" title="&#x2F;imports"></a>&#x2F;imports</h6><p>功能：列出当前活动的 jshell 导入。</p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">jshell&gt; /imports<br>    <span class="hljs-keyword">import</span> java.io.*<br>    <span class="hljs-keyword">import</span> java.math.*<br>    <span class="hljs-keyword">import</span> java.net.*<br>    <span class="hljs-keyword">import</span> java.nio.file.*<br>    <span class="hljs-keyword">import</span> java.util.*<br>    <span class="hljs-keyword">import</span> java.util.concurrent.*<br>    <span class="hljs-keyword">import</span> java.util.function.*<br>    <span class="hljs-keyword">import</span> java.util.prefs.*<br>    <span class="hljs-keyword">import</span> java.util.regex.*<br>    <span class="hljs-keyword">import</span> java.util.stream.*<br></code></pre></td></tr></table></figure><h6 id="exit"><a href="#exit" class="headerlink" title="&#x2F;exit"></a>&#x2F;exit</h6><p>功能：退出 jshell</p><h6 id="env-class-path-module-path-add-modules-…"><a href="#env-class-path-module-path-add-modules-…" class="headerlink" title="&#x2F;env [-class-path &lt;路径&gt;] [-module-path &lt;路径&gt;] [-add-modules &lt;模块&gt;] …"></a>&#x2F;env [-class-path &lt;路径&gt;] [-module-path &lt;路径&gt;] [-add-modules &lt;模块&gt;] …</h6><p>功能：查看或更改上下文。上下文是类路径，模块路径等等。</p><p>使用方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">/env [-class-path &lt;路径&gt;] [-<span class="hljs-keyword">module</span>-path &lt;路径&gt;] [-add-modules &lt;模块&gt;] ...<br>     在至少设置一个选项的情况下, 设置评估上下文。如果<br>     已定义片段, 则将使用新评估上下文重置<br>     执行状态, 并且将重放片段 -- 不显示<br>     重放, 但是将显示错误。这等同于: /reload -quiet<br>     有关上下文选项的详细信息, 请参阅:/help context<br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">/env -add-modules com.greetings<br></code></pre></td></tr></table></figure><h6 id="reset-class-path-module-path-add-modules-…"><a href="#reset-class-path-module-path-add-modules-…" class="headerlink" title="&#x2F;reset [-class-path &lt;路径&gt;] [-module-path &lt;路径&gt;] [-add-modules &lt;模块&gt;]…"></a>&#x2F;reset [-class-path &lt;路径&gt;] [-module-path &lt;路径&gt;] [-add-modules &lt;模块&gt;]…</h6><p>功能：重置 jshell 工具代码和执行状态，所有输入的代码都将丢失，重新执行启动代码，重新启动执行状态。</p><p>使用方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">/reset [-class-path &lt;路径&gt;] [-<span class="hljs-keyword">module</span>-path &lt;路径&gt;] [-add-modules &lt;模块&gt;]...<br></code></pre></td></tr></table></figure><h6 id="reload-restore-quiet-class-path-module-path-…"><a href="#reload-restore-quiet-class-path-module-path-…" class="headerlink" title="&#x2F;reload [-restore] [-quiet] [-class-path &lt;路径&gt;] [-module-path &lt;路径&gt;]…"></a>&#x2F;reload [-restore] [-quiet] [-class-path &lt;路径&gt;] [-module-path &lt;路径&gt;]…</h6><p>功能：重置 jshell 工具代码和执行状态, 然后按照各有效片段和任何 &#x2F;drop 或 &#x2F;classpath 命令的输入顺序重放它们。</p><p>使用方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java">/reload<br>     重置和重放自进入 jshell 以来的有效历史记录,<br>     或者执行 /reset 或 /reload 命令中最新的那个<br>     命令。<br><br>/reload -restore<br>     重置并重放上一次进入 jshell 与最近进入 jshell<br>     之间的有效历史记录, 或者执行 /reset 或 /reload<br>     命令。这进而可用于还原上一个<br>     jshell 工具会话。<br><br>/reload [-restore] -quiet<br>     使用 ‘-quiet’ 参数时, 不显示重放，将显示错误。<br><br>reload 接受上下文选项，有关上下文选项的详细信息, 请参阅:/help context<br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">jshell&gt; /reload<br>|  正在重新启动并还原状态。<br>-: <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>                System.out.println(<span class="hljs-string">&quot;Hello world&quot;</span>);<br>        &#125;<br>   &#125;<br>-: String[] str = &#123;<span class="hljs-string">&quot;test&quot;</span>&#125;;<br>-: Test.main(str)<br>Hello world<br>-: /drop <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h6 id="history"><a href="#history" class="headerlink" title="&#x2F;history"></a>&#x2F;history</h6><p>功能：显示自启动此 jshell 以来输入的片段和命令的历史记录。</p><h6 id="set-editor-start-feedback-mode-prompt-truncation-format-…"><a href="#set-editor-start-feedback-mode-prompt-truncation-format-…" class="headerlink" title="&#x2F;set editor|start|feedback|mode|prompt|truncation|format …"></a>&#x2F;set editor|start|feedback|mode|prompt|truncation|format …</h6><p>功能：设置 jshell 配置信息，包括要使用的外部编辑器、要使用的启动定义、新的反馈模式、命令提示符、要使用的反馈模式或输出的格式。</p><p>使用方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java">/set editor [-wait] &lt;命令&gt; &lt;可选参数&gt;...<br>     指定要为 /edit 命令启动的命令<br>     &lt;命令&gt; 是与操作系统相关的字符串<br><br>/set start &lt;文件&gt;<br>     指定 &lt;文件&gt; 的内容将成为默认启动片段和命令<br><br>/set feedback &lt;模式&gt;<br>     设置用于描述为所输入片段和命令显示的反馈的反馈模式<br><br>/set mode &lt;模式&gt; [&lt;旧模式&gt;] -command|-quiet|-delete<br>     创建或更新用户定义的反馈模式, 可以选择从现有模式复制<br><br>/set prompt &lt;模式&gt; <span class="hljs-string">&quot;&lt;提示&gt;&quot;</span> <span class="hljs-string">&quot;&lt;更多提示&gt;&quot;</span><br>     设置为给定反馈模式显示的提示符<br><br>/set truncation &lt;模式&gt; &lt;长度&gt; &lt;选择器&gt;...<br>     设置显示值的最大长度<br><br>/set format &lt;模式&gt; &lt;字段&gt; <span class="hljs-string">&quot;&lt;格式&gt;&quot;</span> &lt;选择器&gt;...<br>     通过设置当选择器匹配时字段的格式来配置反馈模式<br><br>/set<br>     以 /set 命令形式显示编辑器, 启动和反馈设置<br>     要显示以上任意项的设置, 请忽略 set 值<br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">jshell&gt; /set<br>|  /set editor -<span class="hljs-keyword">default</span><br>|  /set start -<span class="hljs-keyword">default</span><br>|  /set feedback normal<br>|<br>|  可用的反馈模式:<br>|     concise<br>|     normal<br>|     silent<br>|     verbose<br></code></pre></td></tr></table></figure><h6 id><a href="#" class="headerlink" title="&#x2F;? [|]"></a>&#x2F;? [<command>|<subject>]</subject></h6><p>功能：获取 jshell 的相关信息，是 help 的缩写，可以查询命令的使用方法。</p><h6 id="-1"><a href="#-1" class="headerlink" title="&#x2F;!"></a>&#x2F;!</h6><p>功能：重新运行上一个片段</p><h6 id="-2"><a href="#-2" class="headerlink" title="&#x2F;"></a>&#x2F;<id></id></h6><p>功能：按 id 重新运行片段</p><h6 id="-3"><a href="#-3" class="headerlink" title="&#x2F;-"></a>&#x2F;-<n></n></h6><p>功能：重新运行前面的第 n 个片段</p>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>JSHELL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java中的多态</title>
    <link href="/2023/10/10/Java%E4%B8%AD%E7%9A%84%E5%A4%9A%E6%80%81/"/>
    <url>/2023/10/10/Java%E4%B8%AD%E7%9A%84%E5%A4%9A%E6%80%81/</url>
    
    <content type="html"><![CDATA[<p>因为我一直使用Java语言，所以一直以为多态是Java中所特有的概念，但是其实在编程语言和类型论中都有多态的定义，所以之前对多态的理解感觉有些不到位，便做个总结来详细说明一下。</p><p>以下是维基百科的定义：多态（Polymorphism）,指为不同数据类型的实体提供统一的接口，或使用一个单一的符号来表示多个不同的类型。一般情况下，可以把多态分成以下几类：</p><ul><li>特设多态：为个体的特定类型的任意集合定义一个共同接口。</li><li>参数多态：指定一个或多个类型不靠名字而是靠可以标识任何类型的抽象符号。</li><li>子类型：一个名字指称很多不同的类的实例，这些类有某个共同的超类。</li></ul><p>多态在编程语言中都有实现，我们可以使用Java来举例：</p><h4 id="1-特设多态"><a href="#1-特设多态" class="headerlink" title="1.特设多态"></a>1.特设多态</h4><p>概念：多态函数有多个不同的实现，依赖于实参而调用相应版本的函数。</p><p>在Java 中<code>方法重载</code>和<code>方法重写</code>都是特设多态中的实现方式。<code>在C语言中叫做函数，在Java中叫做方法</code>。在C语言中也可以实现函数重载和函数重写。</p><h5 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h5><p>方法重载指的是在同一个类中，多个方法有同样的名称，但是参数列表不相同的情形。</p><p>方法重载是一个编译期概念，因为它是在编译阶段根据参数变量的类型和个数来判断最终要调用哪个方法，所以它也被叫做静态多态。</p><p>为什么方法重载中返回值类型和访问修饰符类型不能作为是否方法重载的判断标准呢？</p><p>因为Java识别一个方法是通过<code>JVM</code>来实现的，而<code>JVM</code>是通过方法签名来决定调用哪个方法，方法签名又是由<strong>方法名称 + 参数类型 + 参数个数</strong>组成的一个唯一值，如果方法的返回类型也作为方法签名的一部分，那么当程序员写了一个代码去调用“重载”的方法时，<code>JVM</code>就不能分辨要调用哪个方法了，所以方法返回值和方法的访问修饰符都不能作为是否方法重载的判断标准，而且被重载的方法也可以改变返回类型和访问修饰符。</p><h5 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h5><p>方法重写也可以叫做方法覆盖，我个人感觉方法覆盖更好理解他是什么，它指的是返回类型、函数名和参数都一样，只是方法的实现体不一样，而且需要满足以下条件。</p><ul><li>访问级别的限制性一定不能比被重写方法的强</li><li>写的方法能够抛出更少或更有限的异常（也就是说，被重写的方法声明了异常，但重写的方法可以什么也不声明）</li><li>不能重写被标示为final的方法</li><li>只能出现在子类和父类中</li></ul><p>方法重写也就是Java多态的实现方式。</p><p>方法重写是一个运行时概念，因为它是在运行时，根据引用变量所指向的实际对象的类型来调用方法。</p><h4 id="2-参数多态"><a href="#2-参数多态" class="headerlink" title="2.参数多态"></a>2.参数多态</h4><p>概念：声明或者定义函数（复合类型、变量）的时候不指定具体的类型，而把这些类型作为参数使用，让该定义对各种具体类型都适用。</p><p>Java中的泛型就是参数多态的一种。</p><h4 id="3-子类型"><a href="#3-子类型" class="headerlink" title="3.子类型"></a>3.子类型</h4><p>概念：在面向对象程序设计中，计算机程序运行时，相同的消息可能会送给多个不同的类别的对象，而系统可依据对象所属类别，引发对应类别的方法，而有不同的行为。</p><p>这种子类型多态其实就是 Java 中常见的多态。</p><p>在Java中多态的定义为同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果。</p><p>Java中多态其实是一种运行期的状态。为了实现运行期的多态，或者说是动态绑定，需要满足三个条件：</p><ul><li>有类继承或者接口实现</li><li>子类要重写父类的方法</li><li>父类的引用指向子类的对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Parent</span>&#123;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">call</span><span class="hljs-params">()</span>&#123;<br>        sout(<span class="hljs-string">&quot;im Parent&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Parent</span>&#123;<span class="hljs-comment">// 1.有类继承或者接口实现</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">call</span><span class="hljs-params">()</span>&#123;<span class="hljs-comment">// 2.子类要重写父类的方法</span><br>        sout(<span class="hljs-string">&quot;im Son&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Daughter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Parent</span>&#123;<span class="hljs-comment">// 1.有类继承或者接口实现</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">call</span><span class="hljs-params">()</span>&#123;<span class="hljs-comment">// 2.子类要重写父类的方法</span><br>        sout(<span class="hljs-string">&quot;im Daughter&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-type">Parent</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Son</span>(); <span class="hljs-comment">//3.父类的引用指向子类的对象</span><br>        <span class="hljs-type">Parent</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Daughter</span>(); <span class="hljs-comment">//3.父类的引用指向子类的对象</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样，就实现了多态，同样是Parent类的实例，p.call 调用的是Son类的实现、p1.call 调用的是Daughter的实现。这也被叫做动态多态。</p><p>有人说，你自己定义的时候不就已经知道 p 是 son，p1 是 Daughter 了么。但是，有些时候你用到的对象并不都是自己声明的。</p><p>比如 Spring 中的 IOC 出来的对象，你在使用的时候就不知道他是谁，或者说你可以不用关心他是谁。根据具体情况而定。</p>]]></content>
    
    
    
    <tags>
      
      <tag>多态</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>maven中的依赖版本号</title>
    <link href="/2023/10/09/maven%E4%B8%AD%E7%9A%84%E4%BE%9D%E8%B5%96%E7%89%88%E6%9C%AC%E5%8F%B7/"/>
    <url>/2023/10/09/maven%E4%B8%AD%E7%9A%84%E4%BE%9D%E8%B5%96%E7%89%88%E6%9C%AC%E5%8F%B7/</url>
    
    <content type="html"><![CDATA[<h4 id="快照版本："><a href="#快照版本：" class="headerlink" title="快照版本："></a>快照版本：</h4><p>SNAPSHOT表示快照版，它不是个稳定版本，属于开发过程中使用的版本。当我们项目处于不停的迭代开发期，如果存在依赖关系，比如 A 项目组开发后发布的新包，被 B 项目组引用，这时候使用快照版本SNAPSHOT，能够在 A 项目组发布到仓库后，自动转为最新时间戳的后缀，供 B 项目组自动引用成功。</p><p>这样的好处是，当我们有依赖关系的两个项目组同时开发时，可以互不影响，每次 A 项目组发布后，B 项目组都会刷新、重新编译的方式，自动更新到最新的 A 项目开发的依赖包。只有当准备进入测试阶段，才会将里程碑版本号的SNAPSHOT替换成alpha或beta，即测试版本。</p><p>如果在项目配置文件中（无论是build.gradle还是pom.xml）指定的版本号带有<strong>’-SNAPSHOT’</strong>后缀，比如版本号为’abc-1.0-SNAPSHOT’，那么打出的包就是一个<strong>快照版本</strong>。</p><h4 id="正式版本："><a href="#正式版本：" class="headerlink" title="正式版本："></a>正式版本：</h4><h5 id="Alpha版"><a href="#Alpha版" class="headerlink" title="Alpha版"></a>Alpha版</h5><p>此版本他表示的是该软件在此阶段，标识内部测试版。α是<a href="https://so.csdn.net/so/search?q=%E5%B8%8C%E8%85%8A%E5%AD%97%E6%AF%8D&spm=1001.2101.3001.7020">希腊字母</a>的第一个，主要是以实现软件功能为主，一般只在软件开发者组内进行交流。也就是，该版本软件的Bug较多，需要继续跟进修复bug。</p><h5 id="Beta版"><a href="#Beta版" class="headerlink" title="Beta版"></a>Beta版</h5><p>β是希腊字母的第二个，标识公开测试版。该版本相对于α版已有了很大发展以及改进，消除了严重的异常，但还是存在着一些缺陷，需要经过很多次的测试来进一步消除问题。这个版本主要是对软件的UI进行修改调整。</p><h5 id="RC版（Release-Candidate）"><a href="#RC版（Release-Candidate）" class="headerlink" title="RC版（Release Candidate）"></a>RC版（Release Candidate）</h5><p>发行候选版本，基本上可以说，不存在导致错误的BUG，与即将发行的正式版相差无几，是最终发布成正式版的前一个版本，将bug修改完就可以发布成正式版了。</p><h5 id="Release版"><a href="#Release版" class="headerlink" title="Release版"></a>Release版</h5><p>该版本意味“最终版本”，也叫做正式发布版，在经过之前版本的一系列测试之后，来到了一个正式版本，是最终交付用户使用的一个版本。该版本也会被称为标准版。通常情况下，Release不会以单词形式出现在软件封面上，而是会有一个符号(Ｒ)。有的用GA来表示正式发布版，比如spring。</p><h5 id="Final版"><a href="#Final版" class="headerlink" title="Final版"></a>Final版</h5><p>最终版，也是正式发布版的一种表示方法，比如Hibernate。</p><h5 id="GA（General-Availability）"><a href="#GA（General-Availability）" class="headerlink" title="GA（General Availability）"></a>GA（General Availability）</h5><p>正式发布的版本，官方开始推荐广泛使用，国外有的用GA来表示release版本。</p><h5 id="Stable"><a href="#Stable" class="headerlink" title="Stable"></a>Stable</h5><p>稳定版，开源软件有的会用stable来表示正式发布的版本，比如Nginx。</p><p>授权和功能划分：</p><p>Trial：试用版，通常都有时间限制，有些试用版软件还在功能上做了一定的限制。可注册或购买成为正式版 </p><p>Unregistered：未注册版，通常没有时间限制，在功能上相对于正式版做了一定的限制。可注册或购买成为正式版。 </p><p>Demo：演示版，仅仅集成了正式版中的几个功能，不能升级成正式版。 </p><p>Lite：精简版。 </p><p>Full　version：完整版，属于正式版。</p><p>其他版本 </p><p>Enhance　：增强版或者加强版　属于正式版1 </p><p>Free　：自由版 </p><p>Release　：发行版　有时间限制 </p><p>Upgrade　：升级版 </p><p>Retail　　：零售版 </p><p>Cardware　：属共享软件的一种，只要给作者回复一封电邮或明信片即可。（有的作者并由此提供注册码等），目前这种形式已不多见。&#x2F;　S </p><p>Plus　：属增强版，不过这种大部分是在程序界面及多媒体功能上增强。 </p><p>Preview　：预览版 </p><p>Corporation　&amp;　Enterprise　：企业版 </p><p>Standard　：标准版 </p><p>Mini　：迷你版也叫精简版只有最基本的功能 </p><p>Premium　：　贵价版 </p><p>Professional(Pro)　：　专业版 </p><p>Express　：　特别版 </p><p>Deluxe　：　豪华版 </p><p>Regged　：　已注册版</p><p>Build:内部标号 </p><p>Delux:豪华版 (deluxe: 豪华的，华丽的) </p><p>DEMO演示版，一般会有功能限制 </p><p>Full:完全版 </p><p>Plus:加强版 </p><p>Trial:试用版（一般有时间或者功能限制）</p><h4 id="快照版本和正式版本的区别："><a href="#快照版本和正式版本的区别：" class="headerlink" title="快照版本和正式版本的区别："></a>快照版本和正式版本的区别：</h4><p>快照版本和正式版本的主要区别在于，本地获取这些依赖的机制有所不同。正式版本”abc-1.0”构建的时候会先在本次仓库中查找是否已经有了这个依赖库，若是没有的话才会去远程仓库中去拉取。假设项目中现在依赖”abc-1.0”，在第一次构建的时候会把该库从远程仓库中下载到本地仓库缓存，之后再次构建都不会去访问远程仓库了。如果远程仓库中代码进行了修改，但版本号依旧叫”abc-1.0”，那么此依赖没法获得最新更新。只有版本号更新后（如”abc-1.1”）才能拉取到最新代码。快照版本”abc-1.0-SNAPSHOT”<br>每次构建时，会优先去远程仓库中查看是否有最新的”abc-1.0-SNAPSHOT.jar”，若是有则下载下来使用。即便本地仓库中已经有了”abc-1.0-SNAPSHOT.jar”，它也会尝试去远程仓库中查看同名的jar是不是最新的。在配置Maven的Repository的时候中有个配置项，能够配置对于SNAPSHOT版本向远程仓库中查找的频率。频率共有四种，分别是always、daily、interval、never。</p><table><thead><tr><th>always</th><th>每次都去远程仓库查看是否有更新</th></tr></thead><tbody><tr><td>daily</td><td>每天只在第一次的时候查看是否有更新，当天的其它时候则不会查看</td></tr><tr><td>interval</td><td>容许设置一个分钟为单位的间隔时间，在这个间隔时间内只会去远程仓库中查找一次</td></tr><tr><td>never</td><td>不会去远程仓库中查找（和正式版本相同）</td></tr></tbody></table>]]></content>
    
    
    
    <tags>
      
      <tag>maven</tag>
      
      <tag>版本号</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/10/09/hello-world/"/>
    <url>/2023/10/09/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>在使用Hexo搭建个人博客过程中的一些注意事项</title>
    <link href="/2023/10/04/%E5%9C%A8%E4%BD%BF%E7%94%A8Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
    <url>/2023/10/04/%E5%9C%A8%E4%BD%BF%E7%94%A8Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</url>
    
    <content type="html"><![CDATA[<h2 id="使用GitHub-Pages-Hexo搭建个人博客网站"><a href="#使用GitHub-Pages-Hexo搭建个人博客网站" class="headerlink" title="使用GitHub Pages + Hexo搭建个人博客网站"></a>使用GitHub Pages + Hexo搭建个人博客网站</h2><h4 id="一、准备工作"><a href="#一、准备工作" class="headerlink" title="一、准备工作"></a>一、准备工作</h4><ol><li><p>GitHub账号</p></li><li><p>安装Git</p></li><li><p>安装NodeJS</p></li></ol><p>  可以网上找一下教程</p><h4 id="二、创建仓库"><a href="#二、创建仓库" class="headerlink" title="二、创建仓库"></a>二、创建仓库</h4><p>在<code>GitHub</code>上创建一个新的代码仓库用于保存网页。</p><p>该仓库名格式必须为<code>&lt;用户名&gt;.github.io</code>，权限设置为公开。</p><p>上传一个 index.html 文件，可以像下面一样，访问<code>&lt;用户名&gt;.github.io</code>网址，可以正常访问的话，进入下一步。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>yaorongke<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello ~<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="三、安装Hexo"><a href="#三、安装Hexo" class="headerlink" title="三、安装Hexo"></a>三、安装Hexo</h4><p><a href="https://hexo.io/zh-cn/">Hexo官网</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">安装 Hexo</span><br>npm install -g hexo-cli<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">在当前目录下创建一个项目 hexo-blog 并初始化</span><br>hexo init hexo-blog<br>cd hexo-blog<br>npm install<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">本地启动</span><br>hexo g<br>hexo server<br></code></pre></td></tr></table></figure><p>浏览器访问 <a href="http://localhost:4000，进入以下界面则安装成功">http://localhost:4000，进入以下界面则安装成功</a></p><p><img src="/2023/10/04/%E5%9C%A8%E4%BD%BF%E7%94%A8Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/656bf025f6934a35abc104b16e4dd2fc.png"></p><h4 id="四、更换主题"><a href="#四、更换主题" class="headerlink" title="四、更换主题"></a>四、更换主题</h4><p>我更换的主题为 <a href="https://github.com/fluid-dev/hexo-theme-fluid">Fluid官网</a>，更换其他主题操作也是一样的。</p><p>配置文件是yml文件，所以要注意在每一个<code>:</code>后面加一个空格。</p><p><strong>安装主题</strong></p><p>下载 <a href="https://github.com/fluid-dev/hexo-theme-fluid/releases">该主题的最新版本</a> 解压到 <code>themes</code> 目录，并将解压出的文件夹重命名为 <code>fluid</code>。</p><p><strong>指定主题</strong></p><p>如下修改 <code>Hexo</code> 博客目录中的 <code>_config.yml</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">theme: fluid  # 指定主题<br>language: zh-CN  # 指定语言，会影响主题显示的语言，按需修改<br></code></pre></td></tr></table></figure><p><strong>创建「关于页」</strong></p><p>首次使用主题的「关于页」需要手动创建：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo new page about<br></code></pre></td></tr></table></figure><p>创建成功后，编辑博客目录下 <code>/source/about/index.md</code>，添加 <code>layout</code> 属性为 about。</p><p><strong>本地启动</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo g -d<br>hexo s<br></code></pre></td></tr></table></figure><p>浏览器访问 <a href="http://localhost:4000，`Fluid`主题风格页面如下则部署成功">http://localhost:4000，`Fluid`主题风格页面如下则部署成功</a></p><p><img src="/2023/10/04/%E5%9C%A8%E4%BD%BF%E7%94%A8Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/b02a3408a62040bdac07bb71435c710e.png"></p><h4 id="五、编辑文章"><a href="#五、编辑文章" class="headerlink" title="五、编辑文章"></a>五、编辑文章</h4><p>编辑文章的操作可以查阅 <a href="https://hexo.io/zh-cn/docs/writing">Hexo写作文档</a>。</p><p>在 Hexo 的配置文件中，有一个属性为post_asset_folder: true，打开这个配置是为了在生成文章的时候生成一个同名的资源目录用于存放图片文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">post_asset_folder: true<br></code></pre></td></tr></table></figure><h4 id="六、修改-Fliut-的页面"><a href="#六、修改-Fliut-的页面" class="headerlink" title="六、修改 Fliut 的页面"></a>六、修改 Fliut 的页面</h4><p>修改 Fluit 的配置文件来实现更改页面样式，可以查阅<a href="https://hexo.fluid-dev.com/docs/start/">Fliut 官方文档</a>。</p><h4 id="七、添加阅读量统计"><a href="#七、添加阅读量统计" class="headerlink" title="七、添加阅读量统计"></a>七、添加阅读量统计</h4><p><strong>申请<a href="https://console.leancloud.cn/">LeanCloud</a>账号并创建应用</strong></p><p>进入该应用的 <code>设置-&gt;应用凭证</code>，找到 <code>AppID</code> 和 <code>AppKey</code>，记录下来后面配置要用。</p><p><strong>修改Fluid配置</strong></p><p>单篇文章阅读量计数。</p><p>打开统计开关。</p><p><img src="/2023/10/04/%E5%9C%A8%E4%BD%BF%E7%94%A8Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/281c1db597dc4751a9fe4be660476045.png" alt="打开统计开关"></p><p>配置 <code>leancloud</code>的 <code>app_id</code> 和 <code>app_key。</code></p><p><img src="/2023/10/04/%E5%9C%A8%E4%BD%BF%E7%94%A8Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/c707838cfa334702803b2ab9fc06501a.png" alt="配置 leancloud 的app_id和app_key"></p><p>打开计数功能，统计来源改为 <code>leancloud。</code></p><p><img src="/2023/10/04/%E5%9C%A8%E4%BD%BF%E7%94%A8Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/08292cdb1d754d9b86c0a80416281ec5.png"></p><p>页面底部展示网站的 PV、UV 统计数。</p><p><img src="/2023/10/04/%E5%9C%A8%E4%BD%BF%E7%94%A8Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/a285eab4997a4b9db2e575b966abb3d1.png"></p><h4 id="八、添加评论功能"><a href="#八、添加评论功能" class="headerlink" title="八、添加评论功能"></a>八、添加评论功能</h4><p><strong>修改Fluid配置</strong></p><p>启用评论插件。<br><img src="/2023/10/04/%E5%9C%A8%E4%BD%BF%E7%94%A8Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/%E5%90%AF%E7%94%A8%E8%AF%84%E8%AE%BA%E6%8F%92%E4%BB%B6.png" alt="启用评论插件"><br>配置 <code>LeanCloud</code> 的 <code>appId</code> 和 <code>appkey</code>。</p><p><img src="/2023/10/04/%E5%9C%A8%E4%BD%BF%E7%94%A8Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/%E9%85%8D%E7%BD%AEleancloud%E7%9A%84appId%E5%92%8CappKey.png" alt="配置 leancloud 的appId和appKey"></p><h4 id="九、发布到GitHub-Pages"><a href="#九、发布到GitHub-Pages" class="headerlink" title="九、发布到GitHub Pages"></a>九、发布到GitHub Pages</h4><p>安装hexo-deployer-git。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm install hexo-deployer-git --save<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">修改Hexo的配置文件</span><br>deploy:<br>  type: git<br>  repo: 自己仓库的地址<br>  branch: main<br>  token: 自己账号的token<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">部署到github</span><br>hexo g -d<br></code></pre></td></tr></table></figure><h4 id="十、修改为自定义域名"><a href="#十、修改为自定义域名" class="headerlink" title="十、修改为自定义域名"></a>十、修改为自定义域名</h4><p>购买域名，购买的为腾讯云的域名，进入<a href="https://console.dnspod.cn/">腾讯云控制台</a>就可以进行对域名的配置了。</p><p>买完后需要进行DNS 配置，进入你的 <strong>domain manager</strong>，然后点击你的域名，进入配置页。</p><p>添加一个 CNAME，将域名指向原来丑陋的 <code>username.github.io</code>。访问你的域名相当于访问了 <code>username.github.io</code><img src="/2023/10/04/%E5%9C%A8%E4%BD%BF%E7%94%A8Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/image-20231004150215327.png" alt="image-20231004150215327"></p><p>然后需要将该域名网站配置到github上，首先在 Settings 中的 pages 页面中的 custom domain 中填入刚刚购买的个人域名，而且当配置国内的 CDN 时，会出现一个warning，这个 warning 忽略掉即可，而且不能 Enforce HTTPS。</p><p><img src="/2023/10/04/%E5%9C%A8%E4%BD%BF%E7%94%A8Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/image-20231004150423051.png" alt="image-20231004150423051"></p><h4 id="十一、报错问题"><a href="#十一、报错问题" class="headerlink" title="十一、报错问题"></a>十一、报错问题</h4><p>1.在上传文章时报以下错误：</p><ul><li>将Hexo配置文件中的GitHub地址中的<code>https://github.com/user-name/user-name.github.io.git/</code>中 https 改为 http。</li><li>删除.deploy_git文件，再执行hexo clean，来清除缓存，再执行部署命令。</li><li>将Hexo中的GitHub地址由<code>https://github.com/user-name/user-name.github.io.git/</code>改为 SSH地址<code>git@github.com:user-name/user-name.github.io.git</code></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">fatal: unable to access &#x27;https://github.com/user-name/user-name.github.io.git/&#x27;: Recv failure: Connection was aborted<br>FATAL Something&#x27;s wrong. Maybe you can find the solution here: https://hexo.io/docs/troubleshooting.html<br>Error: Spawn failed<br>    at ChildProcess.&lt;anonymous&gt; (C:\Users\wqt19\hexo-blog\node_modules\hexo-util\lib\spawn.js:51:21)<br>    at ChildProcess.emit (node:events:526:28)<br>    at ChildProcess.cp.emit (C:\Users\wqt19\hexo-blog\node_modules\cross-spawn\lib\enoent.js:34:29)<br>    at Process.ChildProcess._handle.onexit (node:internal/child_process:291:12)<br></code></pre></td></tr></table></figure><p>2.上传的文章中无法显示图片，可以查阅<a href="https://hexo.io/zh-cn/docs/asset-folders.html">上传图片</a>和<a href="https://etrd.org/2017/01/23/hexo%E4%B8%AD%E5%AE%8C%E7%BE%8E%E6%8F%92%E5%85%A5%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87/">文章</a>。因为我使用的是typora来写文章的，我用来上传图片的方法是安装了 hexo-asset-image 这个插件，这个插件可以自动转换图片路径，但是Hexo配置文件中 <code>post_asset_folder: true</code> 必须打开，打开这个配置的作用上面有提到，然后便可以使用<code>![logo](logo.jpg)</code> 去插入 <code>logo.jpg</code>.，这样在部署的网站上便可以显示出图片来，但是在Typora中无法显示图片。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm install https://github.com/CodeFalling/hexo-asset-image --save<br></code></pre></td></tr></table></figure><p>所以我还采取了以下措施，将typora中引用的图片路径换为<code>/文档同名文件夹/图片名</code>，还打开了typora的插入时自动转义图片URL。</p><p><img src="/2023/10/04/%E5%9C%A8%E4%BD%BF%E7%94%A8Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/image-20231005132601711.png" alt="在typora和Hexo部署在GitHub的网站 上都可以看到"></p><p>类似这样的图片路径便是我最后实现的效果：<code>/%E5%9C%A8%E4%BD%BF%E7%94%A8Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/image-20231005132601711.png</code>，而完整路径为<code>C:/Users/username/hexo-blog/source/_posts/%E5%9C%A8%E4%BD%BF%E7%94%A8Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/image-20231005132601711.png</code></p><p>但是上述步骤不一定都是必须的，但是最后他可以实现在Typora和部署的网站上都能显示图片的目的。</p><p>3.GitHub Pages自定义域名后每次hexo d都会失效解决，只要在source 目录添加一个新文件CNAME就好，CNAME    不带任何后缀，这就是全称，里面写的是你的域名。</p><ol start="4"><li>标题中不能带有特殊符号。例如：()</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>搭建个人博客</tag>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
