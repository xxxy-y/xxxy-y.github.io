<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>JavaShell工具（JShell）</title>
    <link href="/2023/10/12/JavaShell%E5%B7%A5%E5%85%B7%EF%BC%88JShell%EF%BC%89/"/>
    <url>/2023/10/12/JavaShell%E5%B7%A5%E5%85%B7%EF%BC%88JShell%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>REPL(Read Eval Print Loop)意为交互式的编程环境。</p><p>JShell 是 Java 1.9 新增的一个交互式的编程环境工具。它也被称为REPL，REPL(Read Eval Print Loop)意为交互式的编程环境。它允许你无需使用类或者方法包装来执行 Java 语句。它与 Python 的解释器类似，可以直接输入表达式并查看其执行结果。</p><p>一般在验证输入语句结果时才使用。</p><h4 id="JSHELL的基本使用"><a href="#JSHELL的基本使用" class="headerlink" title="JSHELL的基本使用"></a>JSHELL的基本使用</h4><p><strong>开启 JSHELL</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">$ jshell<br>|  欢迎使用 JShell -- 版本 <span class="hljs-number">21</span><br>|  要大致了解该版本, 请键入: /help intro<br></code></pre></td></tr></table></figure><p><strong>JSHELL 定义类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">jshell&gt; <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br>   ...&gt;     <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>   ...&gt;         System.out.println(<span class="hljs-string">&quot;hello world&quot;</span>);<br>   ...&gt;     &#125;<br>   ...&gt; &#125;<br>|  已创建 类 Test<br><br>jshell&gt; <span class="hljs-type">Test</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Test</span>();<br>o ==&gt; Test@3c0f93f1<br></code></pre></td></tr></table></figure><p><strong>JSHELL 定义接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java">jshell&gt; <span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Inter</span>&#123;<br>   ...&gt;     <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">interTest</span><span class="hljs-params">()</span>;<br>   ...&gt; &#125;<br>|  已创建 接口 Inter<br><br>jshell&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">InterImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Inter</span>&#123;<br>   ...&gt;     <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">interTest</span><span class="hljs-params">()</span>&#123;<br>   ...&gt;         System.out.println(<span class="hljs-string">&quot;Inter Test&quot;</span>);<br>   ...&gt;     &#125;<br>   ...&gt; &#125;<br>|  已创建 类 InterImpl<br><br>jshell&gt; <span class="hljs-type">Inter</span> <span class="hljs-variable">inter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterImpl</span>();<br>inter ==&gt; InterImpl@3327bd23<br><br>jshell&gt; inter.interTest();<br>Inter Test<br></code></pre></td></tr></table></figure><p><strong>JSHELL 声明变量、创建方法、调用方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">jshell&gt; <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>x ==&gt; <span class="hljs-number">1</span><br><br>jshell&gt; <span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br>y ==&gt; <span class="hljs-number">2</span><br><br>jshell&gt; <span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span>&#123;<br>   ...&gt; <span class="hljs-keyword">return</span> a + b;<br>   ...&gt; &#125;<br>|  已创建 方法 add(<span class="hljs-type">int</span>,<span class="hljs-type">int</span>)<br><br>jshell&gt; <span class="hljs-type">int</span> <span class="hljs-variable">z</span> <span class="hljs-operator">=</span> add(x,y);<br>z ==&gt; <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p><strong>JSHELL 读取外部文件并执行其中的片段</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">jshell&gt; </span><span class="language-bash">/open D:/develop/Test.txt</span><br></code></pre></td></tr></table></figure><h4 id="JSHELL-主要命令"><a href="#JSHELL-主要命令" class="headerlink" title="JSHELL 主要命令"></a>JSHELL 主要命令</h4><h6 id="list-all-start"><a href="#list-all-start" class="headerlink" title="&#x2F;list [&lt;名称或 id&gt;|-all|-start]"></a>&#x2F;list [&lt;名称或 id&gt;|-all|-start]</h6><p>功能：显示前面带有片段 ID 的片段源。</p><p>使用方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">/list<br>     列出您键入的或使用 /open 读取的当前活动的代码片段<br><br>/list -start<br>     列出自动评估的启动片段<br><br>/list -all<br>     列出所有片段, 包括失败的片段, 覆盖的片段, 删除的片段和启动片段<br><br>/list &lt;名称&gt;<br>     列出具有指定名称的片段 (特别是活动片段)<br><br>/list &lt;id&gt;<br>     列出具有指定片段 ID 的片段<br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java">jshell&gt; /list<br><br>   <span class="hljs-number">1</span> : <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br>           <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>               System.out.println(<span class="hljs-string">&quot;hello world&quot;</span>);<br>           &#125;<br>       &#125;<br>   <span class="hljs-number">2</span> : <span class="hljs-type">Test</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Test</span>();<br>   <span class="hljs-number">3</span> : <span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Inter</span>&#123;<br>           <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">interTest</span><span class="hljs-params">()</span>;<br>       &#125;<br>   <span class="hljs-number">4</span> : <span class="hljs-keyword">class</span> <span class="hljs-title class_">InterImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Inter</span>&#123;<br>           <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">interTest</span><span class="hljs-params">()</span>&#123;<br>               System.out.println(<span class="hljs-string">&quot;Inter Test&quot;</span>);<br>           &#125;<br>       &#125;<br>   <span class="hljs-number">5</span> : <span class="hljs-type">Inter</span> <span class="hljs-variable">inter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterImpl</span>();<br>   <span class="hljs-number">6</span> : inter.interTest();<br></code></pre></td></tr></table></figure><h6 id="edit"><a href="#edit" class="headerlink" title="&#x2F;edit &lt;名称或 id&gt;"></a>&#x2F;edit &lt;名称或 id&gt;</h6><p>功能：在外部编辑器中编辑源的片段。使用 &#x2F;set editor 可以设置要使用的编辑器。如果尚未设置编辑器, 则将启动一个简单的编辑器。</p><p>使用方法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">/edit &lt;名称&gt;<br>     编辑具有指定名称的片段 (特别是活动片段)<br><br>/edit &lt;id&gt;<br>     编辑具有指定片段 id 的片段<br><br>/edit<br>     编辑您键入或使用 /open 读取的当前活动的代码片段<br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">jshell&gt; /edit <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><img src="/2023/10/12/JavaShell%E5%B7%A5%E5%85%B7%EF%BC%88JShell%EF%BC%89/image-20231012190648917.png" alt="image-20231012190648917"></p><h6 id="drop"><a href="#drop" class="headerlink" title="&#x2F;drop &lt;名称或 id&gt;"></a>&#x2F;drop &lt;名称或 id&gt;</h6><p>功能：删除片段 – 使片段处于不活动状态。</p><p>使用方法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">/drop &lt;name&gt;<br>     删除具有指定名称的片段<br><br>/drop &lt;id&gt;<br>     删除具有指定片段 id 的片段<br></code></pre></td></tr></table></figure><p>示例：删除前文中的片段 6</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java">jshell&gt; /drop <span class="hljs-number">6</span><br><br>jshell&gt; /list<br><br>   <span class="hljs-number">1</span> : <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br>           <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>               System.out.println(<span class="hljs-string">&quot;hello world&quot;</span>);<br>           &#125;<br>       &#125;<br>   <span class="hljs-number">2</span> : <span class="hljs-type">Test</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Test</span>();<br>   <span class="hljs-number">3</span> : <span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Inter</span>&#123;<br>           <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">interTest</span><span class="hljs-params">()</span>;<br>       &#125;<br>   <span class="hljs-number">4</span> : <span class="hljs-keyword">class</span> <span class="hljs-title class_">InterImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Inter</span>&#123;<br>           <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">interTest</span><span class="hljs-params">()</span>&#123;<br>               System.out.println(<span class="hljs-string">&quot;Inter Test&quot;</span>);<br>           &#125;<br>       &#125;<br>   <span class="hljs-number">5</span> : <span class="hljs-type">Inter</span> <span class="hljs-variable">inter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterImpl</span>();<br></code></pre></td></tr></table></figure><h6 id="save-all-history-start"><a href="#save-all-history-start" class="headerlink" title="&#x2F;save [-all|-history|-start] &lt;文件&gt;"></a>&#x2F;save [-all|-history|-start] &lt;文件&gt;</h6><p>功能：将指定的片段和&#x2F;或命令保存到指定文件。</p><p>使用方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">/save &lt;文件&gt;<br>     将当前活动片段的源保存到文件<br><br>/save -all &lt;文件&gt;<br>     将所有片段的源保存到文件<br>     这包括覆盖的源, 失败的源以及启动代码<br><br>/save -history &lt;文件&gt;<br>     保存自启动 jshell 以来输入的所有命令和片段的顺序历史记录<br><br>/save -start &lt;文件&gt;<br>     将当前启动定义保存到文件<br></code></pre></td></tr></table></figure><p>示例：列出所有的片段，并保存到指定的文件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">jshell&gt; /save E:/test.txt<br></code></pre></td></tr></table></figure><p><img src="/2023/10/12/JavaShell%E5%B7%A5%E5%85%B7%EF%BC%88JShell%EF%BC%89/image-20231012190959683.png" alt="image-20231012190959683"></p><h6 id="open"><a href="#open" class="headerlink" title="&#x2F;open "></a>&#x2F;open <file></file></h6><p>功能：打开文件并读取其内容作为片段和命令。</p><p>使用方法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">/open &lt;file&gt;<br>     读取指定的文件作为 jshell 输入<br></code></pre></td></tr></table></figure><h6 id="vars-all-start"><a href="#vars-all-start" class="headerlink" title="&#x2F;vars [&lt;名称或 id&gt;|-all|-start]"></a>&#x2F;vars [&lt;名称或 id&gt;|-all|-start]</h6><p>功能： 列出 jshell 变量的类型, 名称和值。</p><p>使用方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">/vars<br>     列出当前活动的 jshell 变量的类型, 名称和值<br><br>/vars &lt;名称&gt;<br>     列出具有指定名称的 jshell 变量 (特别是活动变量)<br><br>/vars &lt;id&gt;<br>     列出具有指定片段 ID 的 jshell 变量<br><br>/vars -start<br>     列出自动添加的启动 jshell 变量<br><br>/vars -all<br>     列出所有 jshell 变量, 包括已失败变量, 已覆盖变量, 已删除变量和启动变量<br></code></pre></td></tr></table></figure><p>示例：列出所有变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">jshell&gt; /vars<br>    String[] str = String[<span class="hljs-number">1</span>] &#123; <span class="hljs-string">&quot;test&quot;</span> &#125;<br></code></pre></td></tr></table></figure><h6 id="methods-all-start"><a href="#methods-all-start" class="headerlink" title="&#x2F;methods [&lt;名称或 id&gt;|-all|-start]"></a>&#x2F;methods [&lt;名称或 id&gt;|-all|-start]</h6><p>功能：列出 jshell 方法的名称, 参数类型以及返回类型。</p><p>使用方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">/methods<br>     列出当前活动 jshell 方法名称, 参数类型和返回类型<br><br>/methods &lt;名称&gt;<br>     列出具有指定名称的 jshell 方法 (特别是活动方法)<br><br>/methods &lt;id&gt;<br>     列出具有指定片段 ID 的 jshell 方法<br><br>/methods -start<br>     列出自动添加的启动 jshell 方法<br><br>/methods -all<br>     列出所有片段, 包括已失败片段, 已覆盖片段, 已删除片段和启动片段<br></code></pre></td></tr></table></figure><p>示例：创建一个方法，列出所有方法，最后执行方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">jshell&gt; <span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span>&#123;<span class="hljs-keyword">return</span> a+b;&#125;<br>  已创建 方法 add(<span class="hljs-type">int</span>,<span class="hljs-type">int</span>)<br>jshell&gt; /methods<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span>,<span class="hljs-type">int</span>)</span><br>jshell&gt; add(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)<br>$<span class="hljs-number">8</span> ==&gt; <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h6 id="types-all-start"><a href="#types-all-start" class="headerlink" title="&#x2F;types [&lt;名称或 id&gt;|-all|-start]"></a>&#x2F;types [&lt;名称或 id&gt;|-all|-start]</h6><p>功能：列出 jshell 类, 接口和枚举。</p><p>使用方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">/types<br>     列出当前活动 jshell 类, 接口和枚举<br><br>/types &lt;名称&gt;<br>     列出具有指定名称的 jshell 类型 (特别是活动类型)<br><br>/types &lt;id&gt;<br>     列出具有指定片段 ID 的 jshell 类型<br><br>/types -start<br>     列出自动添加的启动 jshell 类型<br><br>/types -all<br>     列出所有 jshell 类型, 包括已失败, 已覆盖, 已删除和启动类型<br></code></pre></td></tr></table></figure><p>示例：创建一个接口，然后列出当前活动 jshell 类，接口和枚举。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">jshell&gt; <span class="hljs-keyword">interface</span> <span class="hljs-title class_">inter</span>&#123;<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>;&#125;<br>  已创建 接口 inter<br><br>jshell&gt; /types<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">OpenTest</span><br>    <span class="hljs-keyword">interface</span> <span class="hljs-title class_">inter</span><br></code></pre></td></tr></table></figure><h6 id="imports"><a href="#imports" class="headerlink" title="&#x2F;imports"></a>&#x2F;imports</h6><p>功能：列出当前活动的 jshell 导入。</p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">jshell&gt; /imports<br>    <span class="hljs-keyword">import</span> java.io.*<br>    <span class="hljs-keyword">import</span> java.math.*<br>    <span class="hljs-keyword">import</span> java.net.*<br>    <span class="hljs-keyword">import</span> java.nio.file.*<br>    <span class="hljs-keyword">import</span> java.util.*<br>    <span class="hljs-keyword">import</span> java.util.concurrent.*<br>    <span class="hljs-keyword">import</span> java.util.function.*<br>    <span class="hljs-keyword">import</span> java.util.prefs.*<br>    <span class="hljs-keyword">import</span> java.util.regex.*<br>    <span class="hljs-keyword">import</span> java.util.stream.*<br></code></pre></td></tr></table></figure><h6 id="exit"><a href="#exit" class="headerlink" title="&#x2F;exit"></a>&#x2F;exit</h6><p>功能：退出 jshell</p><h6 id="env-class-path-module-path-add-modules-…"><a href="#env-class-path-module-path-add-modules-…" class="headerlink" title="&#x2F;env [-class-path &lt;路径&gt;] [-module-path &lt;路径&gt;] [-add-modules &lt;模块&gt;] …"></a>&#x2F;env [-class-path &lt;路径&gt;] [-module-path &lt;路径&gt;] [-add-modules &lt;模块&gt;] …</h6><p>功能：查看或更改上下文。上下文是类路径，模块路径等等。</p><p>使用方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">/env [-class-path &lt;路径&gt;] [-<span class="hljs-keyword">module</span>-path &lt;路径&gt;] [-add-modules &lt;模块&gt;] ...<br>     在至少设置一个选项的情况下, 设置评估上下文。如果<br>     已定义片段, 则将使用新评估上下文重置<br>     执行状态, 并且将重放片段 -- 不显示<br>     重放, 但是将显示错误。这等同于: /reload -quiet<br>     有关上下文选项的详细信息, 请参阅:/help context<br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">/env -add-modules com.greetings<br></code></pre></td></tr></table></figure><h6 id="reset-class-path-module-path-add-modules-…"><a href="#reset-class-path-module-path-add-modules-…" class="headerlink" title="&#x2F;reset [-class-path &lt;路径&gt;] [-module-path &lt;路径&gt;] [-add-modules &lt;模块&gt;]…"></a>&#x2F;reset [-class-path &lt;路径&gt;] [-module-path &lt;路径&gt;] [-add-modules &lt;模块&gt;]…</h6><p>功能：重置 jshell 工具代码和执行状态，所有输入的代码都将丢失，重新执行启动代码，重新启动执行状态。</p><p>使用方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">/reset [-class-path &lt;路径&gt;] [-<span class="hljs-keyword">module</span>-path &lt;路径&gt;] [-add-modules &lt;模块&gt;]...<br></code></pre></td></tr></table></figure><h6 id="reload-restore-quiet-class-path-module-path-…"><a href="#reload-restore-quiet-class-path-module-path-…" class="headerlink" title="&#x2F;reload [-restore] [-quiet] [-class-path &lt;路径&gt;] [-module-path &lt;路径&gt;]…"></a>&#x2F;reload [-restore] [-quiet] [-class-path &lt;路径&gt;] [-module-path &lt;路径&gt;]…</h6><p>功能：重置 jshell 工具代码和执行状态, 然后按照各有效片段和任何 &#x2F;drop 或 &#x2F;classpath 命令的输入顺序重放它们。</p><p>使用方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java">/reload<br>     重置和重放自进入 jshell 以来的有效历史记录,<br>     或者执行 /reset 或 /reload 命令中最新的那个<br>     命令。<br><br>/reload -restore<br>     重置并重放上一次进入 jshell 与最近进入 jshell<br>     之间的有效历史记录, 或者执行 /reset 或 /reload<br>     命令。这进而可用于还原上一个<br>     jshell 工具会话。<br><br>/reload [-restore] -quiet<br>     使用 ‘-quiet’ 参数时, 不显示重放，将显示错误。<br><br>reload 接受上下文选项，有关上下文选项的详细信息, 请参阅:/help context<br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">jshell&gt; /reload<br>|  正在重新启动并还原状态。<br>-: <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>                System.out.println(<span class="hljs-string">&quot;Hello world&quot;</span>);<br>        &#125;<br>   &#125;<br>-: String[] str = &#123;<span class="hljs-string">&quot;test&quot;</span>&#125;;<br>-: Test.main(str)<br>Hello world<br>-: /drop <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h6 id="history"><a href="#history" class="headerlink" title="&#x2F;history"></a>&#x2F;history</h6><p>功能：显示自启动此 jshell 以来输入的片段和命令的历史记录。</p><h6 id="set-editor-start-feedback-mode-prompt-truncation-format-…"><a href="#set-editor-start-feedback-mode-prompt-truncation-format-…" class="headerlink" title="&#x2F;set editor|start|feedback|mode|prompt|truncation|format …"></a>&#x2F;set editor|start|feedback|mode|prompt|truncation|format …</h6><p>功能：设置 jshell 配置信息，包括要使用的外部编辑器、要使用的启动定义、新的反馈模式、命令提示符、要使用的反馈模式或输出的格式。</p><p>使用方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java">/set editor [-wait] &lt;命令&gt; &lt;可选参数&gt;...<br>     指定要为 /edit 命令启动的命令<br>     &lt;命令&gt; 是与操作系统相关的字符串<br><br>/set start &lt;文件&gt;<br>     指定 &lt;文件&gt; 的内容将成为默认启动片段和命令<br><br>/set feedback &lt;模式&gt;<br>     设置用于描述为所输入片段和命令显示的反馈的反馈模式<br><br>/set mode &lt;模式&gt; [&lt;旧模式&gt;] -command|-quiet|-delete<br>     创建或更新用户定义的反馈模式, 可以选择从现有模式复制<br><br>/set prompt &lt;模式&gt; <span class="hljs-string">&quot;&lt;提示&gt;&quot;</span> <span class="hljs-string">&quot;&lt;更多提示&gt;&quot;</span><br>     设置为给定反馈模式显示的提示符<br><br>/set truncation &lt;模式&gt; &lt;长度&gt; &lt;选择器&gt;...<br>     设置显示值的最大长度<br><br>/set format &lt;模式&gt; &lt;字段&gt; <span class="hljs-string">&quot;&lt;格式&gt;&quot;</span> &lt;选择器&gt;...<br>     通过设置当选择器匹配时字段的格式来配置反馈模式<br><br>/set<br>     以 /set 命令形式显示编辑器, 启动和反馈设置<br>     要显示以上任意项的设置, 请忽略 set 值<br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">jshell&gt; /set<br>|  /set editor -<span class="hljs-keyword">default</span><br>|  /set start -<span class="hljs-keyword">default</span><br>|  /set feedback normal<br>|<br>|  可用的反馈模式:<br>|     concise<br>|     normal<br>|     silent<br>|     verbose<br></code></pre></td></tr></table></figure><h6 id><a href="#" class="headerlink" title="&#x2F;? [|]"></a>&#x2F;? [<command>|<subject>]</subject></h6><p>功能：获取 jshell 的相关信息，是 help 的缩写，可以查询命令的使用方法。</p><h6 id="-1"><a href="#-1" class="headerlink" title="&#x2F;!"></a>&#x2F;!</h6><p>功能：重新运行上一个片段</p><h6 id="-2"><a href="#-2" class="headerlink" title="&#x2F;"></a>&#x2F;<id></id></h6><p>功能：按 id 重新运行片段</p><h6 id="-3"><a href="#-3" class="headerlink" title="&#x2F;-"></a>&#x2F;-<n></n></h6><p>功能：重新运行前面的第 n 个片段</p>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>JSHELL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java中的多态</title>
    <link href="/2023/10/10/Java%E4%B8%AD%E7%9A%84%E5%A4%9A%E6%80%81/"/>
    <url>/2023/10/10/Java%E4%B8%AD%E7%9A%84%E5%A4%9A%E6%80%81/</url>
    
    <content type="html"><![CDATA[<p>因为我一直使用Java语言，所以一直以为多态是Java中所特有的概念，但是其实在编程语言和类型论中都有多态的定义，所以之前对多态的理解感觉有些不到位，便做个总结来详细说明一下。</p><p>以下是维基百科的定义：多态（Polymorphism）,指为不同数据类型的实体提供统一的接口，或使用一个单一的符号来表示多个不同的类型。一般情况下，可以把多态分成以下几类：</p><ul><li>特设多态：为个体的特定类型的任意集合定义一个共同接口。</li><li>参数多态：指定一个或多个类型不靠名字而是靠可以标识任何类型的抽象符号。</li><li>子类型：一个名字指称很多不同的类的实例，这些类有某个共同的超类。</li></ul><p>多态在编程语言中都有实现，我们可以使用Java来举例：</p><h4 id="1-特设多态"><a href="#1-特设多态" class="headerlink" title="1.特设多态"></a>1.特设多态</h4><p>概念：多态函数有多个不同的实现，依赖于实参而调用相应版本的函数。</p><p>在Java 中<code>方法重载</code>和<code>方法重写</code>都是特设多态中的实现方式。<code>在C语言中叫做函数，在Java中叫做方法</code>。在C语言中也可以实现函数重载和函数重写。</p><h5 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h5><p>方法重载指的是在同一个类中，多个方法有同样的名称，但是参数列表不相同的情形。</p><p>方法重载是一个编译期概念，因为它是在编译阶段根据参数变量的类型和个数来判断最终要调用哪个方法，所以它也被叫做静态多态。</p><p>为什么方法重载中返回值类型和访问修饰符类型不能作为是否方法重载的判断标准呢？</p><p>因为Java识别一个方法是通过<code>JVM</code>来实现的，而<code>JVM</code>是通过方法签名来决定调用哪个方法，方法签名又是由<strong>方法名称 + 参数类型 + 参数个数</strong>组成的一个唯一值，如果方法的返回类型也作为方法签名的一部分，那么当程序员写了一个代码去调用“重载”的方法时，<code>JVM</code>就不能分辨要调用哪个方法了，所以方法返回值和方法的访问修饰符都不能作为是否方法重载的判断标准，而且被重载的方法也可以改变返回类型和访问修饰符。</p><h5 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h5><p>方法重写也可以叫做方法覆盖，我个人感觉方法覆盖更好理解他是什么，它指的是返回类型、函数名和参数都一样，只是方法的实现体不一样，而且需要满足以下条件。</p><ul><li>访问级别的限制性一定不能比被重写方法的强</li><li>写的方法能够抛出更少或更有限的异常（也就是说，被重写的方法声明了异常，但重写的方法可以什么也不声明）</li><li>不能重写被标示为final的方法</li><li>只能出现在子类和父类中</li></ul><p>方法重写也就是Java多态的实现方式。</p><p>方法重写是一个运行时概念，因为它是在运行时，根据引用变量所指向的实际对象的类型来调用方法。</p><h4 id="2-参数多态"><a href="#2-参数多态" class="headerlink" title="2.参数多态"></a>2.参数多态</h4><p>概念：声明或者定义函数（复合类型、变量）的时候不指定具体的类型，而把这些类型作为参数使用，让该定义对各种具体类型都适用。</p><p>Java中的泛型就是参数多态的一种。</p><h4 id="3-子类型"><a href="#3-子类型" class="headerlink" title="3.子类型"></a>3.子类型</h4><p>概念：在面向对象程序设计中，计算机程序运行时，相同的消息可能会送给多个不同的类别的对象，而系统可依据对象所属类别，引发对应类别的方法，而有不同的行为。</p><p>这种子类型多态其实就是 Java 中常见的多态。</p><p>在Java中多态的定义为同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果。</p><p>Java中多态其实是一种运行期的状态。为了实现运行期的多态，或者说是动态绑定，需要满足三个条件：</p><ul><li>有类继承或者接口实现</li><li>子类要重写父类的方法</li><li>父类的引用指向子类的对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Parent</span>&#123;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">call</span><span class="hljs-params">()</span>&#123;<br>        sout(<span class="hljs-string">&quot;im Parent&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Parent</span>&#123;<span class="hljs-comment">// 1.有类继承或者接口实现</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">call</span><span class="hljs-params">()</span>&#123;<span class="hljs-comment">// 2.子类要重写父类的方法</span><br>        sout(<span class="hljs-string">&quot;im Son&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Daughter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Parent</span>&#123;<span class="hljs-comment">// 1.有类继承或者接口实现</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">call</span><span class="hljs-params">()</span>&#123;<span class="hljs-comment">// 2.子类要重写父类的方法</span><br>        sout(<span class="hljs-string">&quot;im Daughter&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-type">Parent</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Son</span>(); <span class="hljs-comment">//3.父类的引用指向子类的对象</span><br>        <span class="hljs-type">Parent</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Daughter</span>(); <span class="hljs-comment">//3.父类的引用指向子类的对象</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样，就实现了多态，同样是Parent类的实例，p.call 调用的是Son类的实现、p1.call 调用的是Daughter的实现。这也被叫做动态多态。</p><p>有人说，你自己定义的时候不就已经知道 p 是 son，p1 是Daughter了么。但是，有些时候你用到的对象并不都是自己声明的。</p><p>比如 Spring 中的 IOC 出来的对象，你在使用的时候就不知道他是谁，或者说你可以不用关心他是谁。根据具体情况而定。</p><p>为什么父类的引用指向子类的对象不会报错，不会发生编译期报错？</p><p>在子类的引用指向父类的对象的情况下，程序未运行编译器就会报错，这是编译期报错，在程序运行时报错是运行时报错，它会发生编译期报错是因为</p>]]></content>
    
    
    
    <tags>
      
      <tag>多态</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>maven中的依赖版本号</title>
    <link href="/2023/10/09/maven%E4%B8%AD%E7%9A%84%E4%BE%9D%E8%B5%96%E7%89%88%E6%9C%AC%E5%8F%B7/"/>
    <url>/2023/10/09/maven%E4%B8%AD%E7%9A%84%E4%BE%9D%E8%B5%96%E7%89%88%E6%9C%AC%E5%8F%B7/</url>
    
    <content type="html"><![CDATA[<h4 id="快照版本："><a href="#快照版本：" class="headerlink" title="快照版本："></a>快照版本：</h4><p>SNAPSHOT表示快照版，它不是个稳定版本，属于开发过程中使用的版本。当我们项目处于不停的迭代开发期，如果存在依赖关系，比如 A 项目组开发后发布的新包，被 B 项目组引用，这时候使用快照版本SNAPSHOT，能够在 A 项目组发布到仓库后，自动转为最新时间戳的后缀，供 B 项目组自动引用成功。</p><p>这样的好处是，当我们有依赖关系的两个项目组同时开发时，可以互不影响，每次 A 项目组发布后，B 项目组都会刷新、重新编译的方式，自动更新到最新的 A 项目开发的依赖包。只有当准备进入测试阶段，才会将里程碑版本号的SNAPSHOT替换成alpha或beta，即测试版本。</p><p>如果在项目配置文件中（无论是build.gradle还是pom.xml）指定的版本号带有<strong>’-SNAPSHOT’</strong>后缀，比如版本号为’abc-1.0-SNAPSHOT’，那么打出的包就是一个<strong>快照版本</strong>。</p><h4 id="正式版本："><a href="#正式版本：" class="headerlink" title="正式版本："></a>正式版本：</h4><h5 id="Alpha版"><a href="#Alpha版" class="headerlink" title="Alpha版"></a>Alpha版</h5><p>此版本他表示的是该软件在此阶段，标识内部测试版。α是<a href="https://so.csdn.net/so/search?q=%E5%B8%8C%E8%85%8A%E5%AD%97%E6%AF%8D&spm=1001.2101.3001.7020">希腊字母</a>的第一个，主要是以实现软件功能为主，一般只在软件开发者组内进行交流。也就是，该版本软件的Bug较多，需要继续跟进修复bug。</p><h5 id="Beta版"><a href="#Beta版" class="headerlink" title="Beta版"></a>Beta版</h5><p>β是希腊字母的第二个，标识公开测试版。该版本相对于α版已有了很大发展以及改进，消除了严重的异常，但还是存在着一些缺陷，需要经过很多次的测试来进一步消除问题。这个版本主要是对软件的UI进行修改调整。</p><h5 id="RC版（Release-Candidate）"><a href="#RC版（Release-Candidate）" class="headerlink" title="RC版（Release Candidate）"></a>RC版（Release Candidate）</h5><p>发行候选版本，基本上可以说，不存在导致错误的BUG，与即将发行的正式版相差无几，是最终发布成正式版的前一个版本，将bug修改完就可以发布成正式版了。</p><h5 id="Release版"><a href="#Release版" class="headerlink" title="Release版"></a>Release版</h5><p>该版本意味“最终版本”，也叫做正式发布版，在经过之前版本的一系列测试之后，来到了一个正式版本，是最终交付用户使用的一个版本。该版本也会被称为标准版。通常情况下，Release不会以单词形式出现在软件封面上，而是会有一个符号(Ｒ)。有的用GA来表示正式发布版，比如spring。</p><h5 id="Final版"><a href="#Final版" class="headerlink" title="Final版"></a>Final版</h5><p>最终版，也是正式发布版的一种表示方法，比如Hibernate。</p><h5 id="GA（General-Availability）"><a href="#GA（General-Availability）" class="headerlink" title="GA（General Availability）"></a>GA（General Availability）</h5><p>正式发布的版本，官方开始推荐广泛使用，国外有的用GA来表示release版本。</p><h5 id="Stable"><a href="#Stable" class="headerlink" title="Stable"></a>Stable</h5><p>稳定版，开源软件有的会用stable来表示正式发布的版本，比如Nginx。</p><p>授权和功能划分：</p><p>Trial：试用版，通常都有时间限制，有些试用版软件还在功能上做了一定的限制。可注册或购买成为正式版 </p><p>Unregistered：未注册版，通常没有时间限制，在功能上相对于正式版做了一定的限制。可注册或购买成为正式版。 </p><p>Demo：演示版，仅仅集成了正式版中的几个功能，不能升级成正式版。 </p><p>Lite：精简版。 </p><p>Full　version：完整版，属于正式版。</p><p>其他版本 </p><p>Enhance　：增强版或者加强版　属于正式版1 </p><p>Free　：自由版 </p><p>Release　：发行版　有时间限制 </p><p>Upgrade　：升级版 </p><p>Retail　　：零售版 </p><p>Cardware　：属共享软件的一种，只要给作者回复一封电邮或明信片即可。（有的作者并由此提供注册码等），目前这种形式已不多见。&#x2F;　S </p><p>Plus　：属增强版，不过这种大部分是在程序界面及多媒体功能上增强。 </p><p>Preview　：预览版 </p><p>Corporation　&amp;　Enterprise　：企业版 </p><p>Standard　：标准版 </p><p>Mini　：迷你版也叫精简版只有最基本的功能 </p><p>Premium　：　贵价版 </p><p>Professional(Pro)　：　专业版 </p><p>Express　：　特别版 </p><p>Deluxe　：　豪华版 </p><p>Regged　：　已注册版</p><p>Build:内部标号 </p><p>Delux:豪华版 (deluxe: 豪华的，华丽的) </p><p>DEMO演示版，一般会有功能限制 </p><p>Full:完全版 </p><p>Plus:加强版 </p><p>Trial:试用版（一般有时间或者功能限制）</p><h4 id="快照版本和正式版本的区别："><a href="#快照版本和正式版本的区别：" class="headerlink" title="快照版本和正式版本的区别："></a>快照版本和正式版本的区别：</h4><p>快照版本和正式版本的主要区别在于，本地获取这些依赖的机制有所不同。正式版本”abc-1.0”构建的时候会先在本次仓库中查找是否已经有了这个依赖库，若是没有的话才会去远程仓库中去拉取。假设项目中现在依赖”abc-1.0”，在第一次构建的时候会把该库从远程仓库中下载到本地仓库缓存，之后再次构建都不会去访问远程仓库了。如果远程仓库中代码进行了修改，但版本号依旧叫”abc-1.0”，那么此依赖没法获得最新更新。只有版本号更新后（如”abc-1.1”）才能拉取到最新代码。快照版本”abc-1.0-SNAPSHOT”<br>每次构建时，会优先去远程仓库中查看是否有最新的”abc-1.0-SNAPSHOT.jar”，若是有则下载下来使用。即便本地仓库中已经有了”abc-1.0-SNAPSHOT.jar”，它也会尝试去远程仓库中查看同名的jar是不是最新的。在配置Maven的Repository的时候中有个配置项，能够配置对于SNAPSHOT版本向远程仓库中查找的频率。频率共有四种，分别是always、daily、interval、never。</p><table><thead><tr><th>always</th><th>每次都去远程仓库查看是否有更新</th></tr></thead><tbody><tr><td>daily</td><td>每天只在第一次的时候查看是否有更新，当天的其它时候则不会查看</td></tr><tr><td>interval</td><td>容许设置一个分钟为单位的间隔时间，在这个间隔时间内只会去远程仓库中查找一次</td></tr><tr><td>never</td><td>不会去远程仓库中查找（和正式版本相同）</td></tr></tbody></table>]]></content>
    
    
    
    <tags>
      
      <tag>maven</tag>
      
      <tag>版本号</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在使用Hexo搭建个人博客过程中的一些注意事项</title>
    <link href="/2023/10/04/%E5%9C%A8%E4%BD%BF%E7%94%A8Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
    <url>/2023/10/04/%E5%9C%A8%E4%BD%BF%E7%94%A8Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</url>
    
    <content type="html"><![CDATA[<h2 id="使用GitHub-Pages-Hexo搭建个人博客网站"><a href="#使用GitHub-Pages-Hexo搭建个人博客网站" class="headerlink" title="使用GitHub Pages + Hexo搭建个人博客网站"></a>使用GitHub Pages + Hexo搭建个人博客网站</h2><h4 id="一、准备工作"><a href="#一、准备工作" class="headerlink" title="一、准备工作"></a>一、准备工作</h4><ol><li><p>GitHub账号</p></li><li><p>安装Git</p></li><li><p>安装NodeJS</p></li></ol><p>  可以网上找一下教程</p><h4 id="二、创建仓库"><a href="#二、创建仓库" class="headerlink" title="二、创建仓库"></a>二、创建仓库</h4><p>在<code>GitHub</code>上创建一个新的代码仓库用于保存网页。</p><p>该仓库名格式必须为<code>&lt;用户名&gt;.github.io</code>，权限设置为公开。</p><p>上传一个 index.html 文件，可以像下面一样，访问<code>&lt;用户名&gt;.github.io</code>网址，可以正常访问的话，进入下一步。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>yaorongke<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello ~<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="三、安装Hexo"><a href="#三、安装Hexo" class="headerlink" title="三、安装Hexo"></a>三、安装Hexo</h4><p><a href="https://hexo.io/zh-cn/">Hexo官网</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">安装 Hexo</span><br>npm install -g hexo-cli<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">在当前目录下创建一个项目 hexo-blog 并初始化</span><br>hexo init hexo-blog<br>cd hexo-blog<br>npm install<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">本地启动</span><br>hexo g<br>hexo server<br></code></pre></td></tr></table></figure><p>浏览器访问 <a href="http://localhost:4000，进入以下界面则安装成功">http://localhost:4000，进入以下界面则安装成功</a></p><p><img src="/2023/10/04/%E5%9C%A8%E4%BD%BF%E7%94%A8Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/656bf025f6934a35abc104b16e4dd2fc.png"></p><h4 id="四、更换主题"><a href="#四、更换主题" class="headerlink" title="四、更换主题"></a>四、更换主题</h4><p>我更换的主题为 <a href="https://github.com/fluid-dev/hexo-theme-fluid">Fluid官网</a>，更换其他主题操作也是一样的。</p><p>配置文件是yml文件，所以要注意在每一个<code>:</code>后面加一个空格。</p><p><strong>安装主题</strong></p><p>下载 <a href="https://github.com/fluid-dev/hexo-theme-fluid/releases">该主题的最新版本</a> 解压到 <code>themes</code> 目录，并将解压出的文件夹重命名为 <code>fluid</code>。</p><p><strong>指定主题</strong></p><p>如下修改 <code>Hexo</code> 博客目录中的 <code>_config.yml</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">theme: fluid  # 指定主题<br>language: zh-CN  # 指定语言，会影响主题显示的语言，按需修改<br></code></pre></td></tr></table></figure><p><strong>创建「关于页」</strong></p><p>首次使用主题的「关于页」需要手动创建：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo new page about<br></code></pre></td></tr></table></figure><p>创建成功后，编辑博客目录下 <code>/source/about/index.md</code>，添加 <code>layout</code> 属性为 about。</p><p><strong>本地启动</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo g -d<br>hexo s<br></code></pre></td></tr></table></figure><p>浏览器访问 <a href="http://localhost:4000，`Fluid`主题风格页面如下则部署成功">http://localhost:4000，`Fluid`主题风格页面如下则部署成功</a></p><p><img src="/2023/10/04/%E5%9C%A8%E4%BD%BF%E7%94%A8Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/b02a3408a62040bdac07bb71435c710e.png"></p><h4 id="五、编辑文章"><a href="#五、编辑文章" class="headerlink" title="五、编辑文章"></a>五、编辑文章</h4><p>编辑文章的操作可以查阅 <a href="https://hexo.io/zh-cn/docs/writing">Hexo写作文档</a>。</p><p>在 Hexo 的配置文件中，有一个属性为post_asset_folder: true，打开这个配置是为了在生成文章的时候生成一个同名的资源目录用于存放图片文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">post_asset_folder: true<br></code></pre></td></tr></table></figure><h4 id="六、修改-Fliut-的页面"><a href="#六、修改-Fliut-的页面" class="headerlink" title="六、修改 Fliut 的页面"></a>六、修改 Fliut 的页面</h4><p>修改 Fluit 的配置文件来实现更改页面样式，可以查阅<a href="https://hexo.fluid-dev.com/docs/start/">Fliut 官方文档</a>。</p><h4 id="七、添加阅读量统计"><a href="#七、添加阅读量统计" class="headerlink" title="七、添加阅读量统计"></a>七、添加阅读量统计</h4><p><strong>申请<a href="https://console.leancloud.cn/">LeanCloud</a>账号并创建应用</strong></p><p>进入该应用的 <code>设置-&gt;应用凭证</code>，找到 <code>AppID</code> 和 <code>AppKey</code>，记录下来后面配置要用。</p><p><strong>修改Fluid配置</strong></p><p>单篇文章阅读量计数。</p><p>打开统计开关。</p><p><img src="/2023/10/04/%E5%9C%A8%E4%BD%BF%E7%94%A8Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/281c1db597dc4751a9fe4be660476045.png" alt="打开统计开关"></p><p>配置 <code>leancloud</code>的 <code>app_id</code> 和 <code>app_key。</code></p><p><img src="/2023/10/04/%E5%9C%A8%E4%BD%BF%E7%94%A8Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/c707838cfa334702803b2ab9fc06501a.png" alt="配置 leancloud 的app_id和app_key"></p><p>打开计数功能，统计来源改为 <code>leancloud。</code></p><p><img src="/2023/10/04/%E5%9C%A8%E4%BD%BF%E7%94%A8Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/08292cdb1d754d9b86c0a80416281ec5.png"></p><p>页面底部展示网站的 PV、UV 统计数。</p><p><img src="/2023/10/04/%E5%9C%A8%E4%BD%BF%E7%94%A8Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/a285eab4997a4b9db2e575b966abb3d1.png"></p><h4 id="八、添加评论功能"><a href="#八、添加评论功能" class="headerlink" title="八、添加评论功能"></a>八、添加评论功能</h4><p><strong>修改Fluid配置</strong></p><p>启用评论插件。<br><img src="/2023/10/04/%E5%9C%A8%E4%BD%BF%E7%94%A8Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/%E5%90%AF%E7%94%A8%E8%AF%84%E8%AE%BA%E6%8F%92%E4%BB%B6.png" alt="启用评论插件"><br>配置 <code>LeanCloud</code> 的 <code>appId</code> 和 <code>appkey</code>。</p><p><img src="/2023/10/04/%E5%9C%A8%E4%BD%BF%E7%94%A8Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/%E9%85%8D%E7%BD%AEleancloud%E7%9A%84appId%E5%92%8CappKey.png" alt="配置 leancloud 的appId和appKey"></p><h4 id="九、发布到GitHub-Pages"><a href="#九、发布到GitHub-Pages" class="headerlink" title="九、发布到GitHub Pages"></a>九、发布到GitHub Pages</h4><p>安装hexo-deployer-git。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm install hexo-deployer-git --save<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">修改Hexo的配置文件</span><br>deploy:<br>  type: git<br>  repo: 自己仓库的地址<br>  branch: main<br>  token: 自己账号的token<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">部署到github</span><br>hexo g -d<br></code></pre></td></tr></table></figure><h4 id="十、修改为自定义域名"><a href="#十、修改为自定义域名" class="headerlink" title="十、修改为自定义域名"></a>十、修改为自定义域名</h4><p>购买域名，购买的为腾讯云的域名，进入<a href="https://console.dnspod.cn/">腾讯云控制台</a>就可以进行对域名的配置了。</p><p>买完后需要进行DNS 配置，进入你的 <strong>domain manager</strong>，然后点击你的域名，进入配置页。</p><p>添加一个 CNAME，将域名指向原来丑陋的 <code>username.github.io</code>。访问你的域名相当于访问了 <code>username.github.io</code><img src="/2023/10/04/%E5%9C%A8%E4%BD%BF%E7%94%A8Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/image-20231004150215327.png" alt="image-20231004150215327"></p><p>然后需要将该域名网站配置到github上，首先在 Settings 中的 pages 页面中的 custom domain 中填入刚刚购买的个人域名，而且当配置国内的 CDN 时，会出现一个warning，这个 warning 忽略掉即可，而且不能 Enforce HTTPS。</p><p><img src="/2023/10/04/%E5%9C%A8%E4%BD%BF%E7%94%A8Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/image-20231004150423051.png" alt="image-20231004150423051"></p><h4 id="十一、报错问题"><a href="#十一、报错问题" class="headerlink" title="十一、报错问题"></a>十一、报错问题</h4><p>1.在上传文章时报以下错误：</p><ul><li>将Hexo配置文件中的GitHub地址中的<code>https://github.com/user-name/user-name.github.io.git/</code>中 https 改为 http。</li><li>删除.deploy_git文件，再执行hexo clean，来清除缓存，再执行部署命令。</li><li>将Hexo中的GitHub地址由<code>https://github.com/user-name/user-name.github.io.git/</code>改为 SSH地址<code>git@github.com:user-name/user-name.github.io.git</code></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">fatal: unable to access &#x27;https://github.com/user-name/user-name.github.io.git/&#x27;: Recv failure: Connection was aborted<br>FATAL Something&#x27;s wrong. Maybe you can find the solution here: https://hexo.io/docs/troubleshooting.html<br>Error: Spawn failed<br>    at ChildProcess.&lt;anonymous&gt; (C:\Users\wqt19\hexo-blog\node_modules\hexo-util\lib\spawn.js:51:21)<br>    at ChildProcess.emit (node:events:526:28)<br>    at ChildProcess.cp.emit (C:\Users\wqt19\hexo-blog\node_modules\cross-spawn\lib\enoent.js:34:29)<br>    at Process.ChildProcess._handle.onexit (node:internal/child_process:291:12)<br></code></pre></td></tr></table></figure><p>2.上传的文章中无法显示图片，可以查阅<a href="https://hexo.io/zh-cn/docs/asset-folders.html">上传图片</a>和<a href="https://etrd.org/2017/01/23/hexo%E4%B8%AD%E5%AE%8C%E7%BE%8E%E6%8F%92%E5%85%A5%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87/">文章</a>。因为我使用的是typora来写文章的，我用来上传图片的方法是安装了 hexo-asset-image 这个插件，这个插件可以自动转换图片路径，但是Hexo配置文件中 <code>post_asset_folder: true</code> 必须打开，打开这个配置的作用上面有提到，然后便可以使用<code>![logo](logo.jpg)</code> 去插入 <code>logo.jpg</code>.，这样在部署的网站上便可以显示出图片来，但是在Typora中无法显示图片。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm install https://github.com/CodeFalling/hexo-asset-image --save<br></code></pre></td></tr></table></figure><p>所以我还采取了以下措施，将typora中引用的图片路径换为<code>/文档同名文件夹/图片名</code>，还打开了typora的插入时自动转义图片URL。</p><p><img src="/2023/10/04/%E5%9C%A8%E4%BD%BF%E7%94%A8Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/image-20231005132601711.png" alt="在typora和Hexo部署在GitHub的网站 上都可以看到"></p><p>类似这样的图片路径便是我最后实现的效果：<code>/%E5%9C%A8%E4%BD%BF%E7%94%A8Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/image-20231005132601711.png</code>，而完整路径为<code>C:/Users/username/hexo-blog/source/_posts/%E5%9C%A8%E4%BD%BF%E7%94%A8Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/image-20231005132601711.png</code></p><p>但是上述步骤不一定都是必须的，但是最后他可以实现在Typora和部署的网站上都能显示图片的目的。</p><p>3.GitHub Pages自定义域名后每次hexo d都会失效解决，只要在source 目录添加一个新文件CNAME就好，CNAME    不带任何后缀，这就是全称，里面写的是你的域名。</p>]]></content>
    
    
    
    <tags>
      
      <tag>搭建个人博客</tag>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
